\documentclass{amsart}

\usepackage{amssymb, amscd,stmaryrd,setspace,hyperref,color}

\input xy
\xyoption{all} \xyoption{poly} \xyoption{knot}\xyoption{curve}
\input{diagxy}


\newcommand{\comment}[1]{}

\newcommand{\longnote}[2][4.9in]{\fcolorbox{black}{yellow}{\parbox{#1}{\color{black} #2}}}
\newcommand{\note}[1]{\fcolorbox{black}{yellow}{\color{black} #1}}
\newcommand{\q}[1]{\begin{question}#1\end{question}}
\newcommand{\g}[1]{\begin{guess}#1\end{guess}}

\def\tn{\textnormal}
\def\mf{\mathfrak}
\def\mc{\mathcal}

\def\ZZ{{\mathbb Z}}
\def\QQ{{\mathbb Q}}
\def\RR{{\mathbb R}}
\def\CC{{\mathbb C}}
\def\AA{{\mathbb A}}
\def\PP{{\mathbb P}}
\def\NN{{\mathbb N}}

\def\Hom{\tn{Hom}}
\def\Fun{\tn{Fun}}
\def\Ob{\tn{Ob}}
\def\Op{\tn{Op}}

\def\to{\rightarrow}
\def\from{\leftarrow}
\def\cross{\times}
\def\taking{\colon}
\def\inj{\hookrightarrow}
\def\surj{\twoheadrightarrow}
\def\too{\longrightarrow}
\def\tooo{\longlongrightarrow}
\def\tto{\rightrightarrows}
\def\ttto{\equiv\!\!>}
\def\ss{\subset}
\def\superset{\supset}
\def\iso{\cong}
\def\down{\downarrow}
\def\|{{\;|\;}}
\def\m1{{-1}}
\def\op{^\tn{op}}
\def\loc{\tn{loc}}
\def\la{\langle}
\def\ra{\rangle}
\def\wt{\widetilde}
\def\wh{\widehat}
\def\we{\simeq}
\def\ol{\overline}
\def\ul{\underline}
\def\qeq{\mathop{=}^?}

\def\ullimit{\ar@{}[rd]|(.3)*+{\lrcorner}}
\def\urlimit{\ar@{}[ld]|(.3)*+{\llcorner}}
\def\lllimit{\ar@{}[ru]|(.3)*+{\urcorner}}
\def\lrlimit{\ar@{}[lu]|(.3)*+{\ulcorner}}
\def\ulhlimit{\ar@{}[rd]|(.3)*+{\diamond}}
\def\urhlimit{\ar@{}[ld]|(.3)*+{\diamond}}
\def\llhlimit{\ar@{}[ru]|(.3)*+{\diamond}}
\def\lrhlimit{\ar@{}[lu]|(.3)*+{\diamond}}
\newcommand{\clabel}[1]{\ar@{}[rd]|(.5)*+{#1}}

\newcommand{\arr}[1]{\ar@<.5ex>[#1]\ar@<-.5ex>[#1]}
\newcommand{\arrr}[1]{\ar@<.7ex>[#1]\ar@<0ex>[#1]\ar@<-.7ex>[#1]}
\newcommand{\arrrr}[1]{\ar@<.9ex>[#1]\ar@<.3ex>[#1]\ar@<-.3ex>[#1]\ar@<-.9ex>[#1]}
\newcommand{\arrrrr}[1]{\ar@<1ex>[#1]\ar@<.5ex>[#1]\ar[#1]\ar@<-.5ex>[#1]\ar@<-1ex>[#1]}

\newcommand{\To}[1]{\xrightarrow{#1}}
\newcommand{\Too}[1]{\xrightarrow{\ \ #1\ \ }}
\newcommand{\From}[1]{\xleftarrow{#1}}

\newcommand{\Adjoint}[4]{\xymatrix@1{#2 \ar@<.5ex>[r]^-{#1} & #3 \ar@<.5ex>[l]^-{#4}}}

\def\id{\tn{id}}
\def\Top{{\bf Top}}
\def\Cat{{\bf Cat}}
\def\Str{{\bf Str}}
\def\Sets{{\bf Sets}}
\def\Set{{\bf Set}}
\def\sSet{{\bf sSet}}
\def\sSets{{\bf sSets}}
\def\Grpd{{\bf Grpd}}
\def\Pre{{\bf Pre}}
\def\Shv{{\bf Shv}}
\def\Rings{{\bf Rings}}

\def\colim{\mathop{\tn{colim}}}

\def\mcA{\mc{A}}
\def\mcB{\mc{B}}
\def\mcC{\mc{C}}
\def\mcD{\mc{D}}
\def\mcE{\mc{E}}
\def\mcF{\mc{F}}
\def\mcG{\mc{G}}
\def\mcH{\mc{H}}
\def\mcI{\mc{I}}
\def\mcJ{\mc{J}}
\def\mcK{\mc{K}}
\def\mcL{\mc{L}}
\def\mcM{\mc{M}}
\def\mcN{\mc{N}}
\def\mcO{\mc{O}}
\def\mcP{\mc{P}}
\def\mcQ{\mc{Q}}
\def\mcR{\mc{R}}
\def\mcS{\mc{S}}
\def\mcT{\mc{T}}
\def\mcU{\mc{U}}
\def\mcV{\mc{V}}
\def\mcW{\mc{W}}
\def\mcX{\mc{X}}
\def\mcY{\mc{Y}}
\def\mcZ{\mc{Z}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{fact}[theorem]{Fact}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{warning}[theorem]{Warning}
\newtheorem{question}[theorem]{Question}
\newtheorem{guess}[theorem]{Guess}
\newtheorem{answer}[theorem]{Answer}
\newtheorem{construction}[theorem]{Construction}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{postulate}[theorem]{Postulate}

\def\Finm{{\bf Fin_{m}}}
\def\El{{\bf El}}
\def\Gr{{\bf Gr}}
\def\U{{\bf U}}
\def\DT{{\bf DT}}
\def\DB{{\bf DB}}
\def\Tables{{\bf Tables}}
\def\Sch{{\bf Sch}}
\def\Fin{{\bf Fin}}
\def\P{{\bf P}}
\def\SC{{\bf SC}}
\def\ND{{\bf ND}}
\def\Poset{{\bf Poset}}
\def\'{\textnormal{'}}

%%%%%

\begin{document}

\title{Categorical description of Peter Gates's Dictionary Pattern}

\author{David I. Spivak}

\thanks{This project was supported in part by a grant from the Office of Naval Research: N000140910466.}

\maketitle

\section{Introduction}

The data dictionary pattern is a broad view of what a database is.  Interestingly, this pattern itself can be expressed as a database.  A slide deck on the subject, written by Peter Gates, can be found here at: \href{http://www.uoregon.edu/~dspivak/cs/db_dic.pdf}{\tt http://www.uoregon.edu/$\sim$dspivak/cs/db\_dic.pdf}.  In this note, I will give a category theoretic description of this idea.

I will use the following idea for labeling data columns.

\begin{remark}\label{rem:1-col tables}

One can imagine each data type as a table with one column and a row for each possible value of that data type.  For example the data type char(1) can be represented as a table $T_{\tn{char(1)}}$  with one column and 26 rows.  Similarly the data type char(2) can be represented as a table $T_{\tn{char(2)}}$ with one column and $26*26=676$ rows.  The table for integers would be huge or theoretically infinite, but at least one can consider it abstractly in the same way as char(10).

\end{remark}

In this short note, we attempt to formulate Gates's ideas in a categorical way.  We do this by drawing each table as a node and each foreign-key column as an arrows from the source table to the target table.  We also draw each data column as an arrow from the table to the 1-column table as in Remark \ref{rem:1-col tables}.

The resulting figures below appear as graphs.  Since we assume that every table has a distinguished primary key, each is in fact a reflexive graph (meaning each node in it has an arrow pointing to itself).  We do not draw these reflexive arrows for typographical reasons.  

Finally, we sometimes want to ensure that two different paths through a graph agree.  For example, each cell in a database appears in a unique column and row.  Each column and each row appear in a unique table.  For each cell, the table of its column must be the same as the table of its row.  We would say that the diagram \begin{align}\label{dia:commute}\xymatrix{\tn{Cell}\ar[r]\ar[d]&\tn{Row}\ar[d]\\\tn{Column}\ar[r]&\tn{Table}}\end{align} {\em commutes}.

\section{The dictionary pattern}

The following is a reformulation of slide 2.  What Gates calls ``Value" I am calling ``Cell".  There are two paths from Cell to Table -- these commute.  There are also two paths from Column to $T_{\tn String}$ -- these do not commute. 

$$\xymatrix@=1.7cm{&\tn{Table}\ar[rr]^{\tn{Name}}&&T_\tn{String}\\\tn{Row}\ar[ur]^{\tn{fk\_row\_table}\;\;}&&\tn{Column}\ar[ur]_{\tn{Name}}\ar[ul]_{\;\;\tn{ fk\_column\_table}}\\&\tn{Cell}\ar[ul]^{\tn{fk\_cell\_row}}\ar[ur]_{\;\;\tn{fk\_cell\_column}}\ar[rr]_{\tn{fk\_cell\_u}}&&\U}$$

The seven arrows above correspond to Gates's seven non-id columns. 

\subsection{Typing the columns}

Let us add information about the type of a column as follows.  Let $\DT$ denote the set of datatypes, $\U$ the disjoint union of their domains, and $\pi\taking\U\to\DT$ the function that associates each instance to its type.  We can think of $\DT$ as a table of data types, think of $\U$ as a table of their instances (which of course is impractical given its size, but in theory fine), and think of $\pi$ as a foreign key with source $\U$ and target $\DT$.  We now have:


 $$\xymatrix{&\tn{Table}\ar[rr]^{\tn{Name}}&&T_\tn{String}\\\tn{Row}\ar[ur]&&\tn{Column}\ar[ur]_{\tn{Name}}\ar[rr]\ar[ul]&&\DT\\&\tn{Cell}\ar[ul]\ar[ur]\ar[rrr]&&&\U\ar[u]}$$ 

\begin{remark}\label{rem:naming arrows}

Given a foreign key with source $A$ and target $B$, Gates names it $fk\_A\_B$.  In my opinion this naming system has several drawbacks.

In category theory, every arrow has a source and target, just like a foreign key does.  Since each arrow is typically drawn from the source to the target, there is no need to include the name of the source and target of an arrow when naming the arrow.  In other words, if an arrow goes from $A$ to $B$, we can call it $f\taking A\to B$, rather than something like \tn{fk\_$A$\_$B$}.  This frees us to name the arrow by its meaning rather than its syntax.  Moreover, we may also have multiple arrows from $A$ to $B$, which Gates's naming system may have a harder time handling.

We shall therefore adopt the convention that an arrow may have any name, such as $f\taking A\to B$.  This arrow will represent a foreign key column in table $A$ that refers to the primary key column of table $B$, and this foreign key will be named $f$.  

We also draw data columns of table $A$  (i.e. columns of $A$ that are not foreign keys) as arrows out of $A$.  The target of such an arrow will be the data type of that column.  This is in keeping with [Spivak.  A simple model of databases].   See Remark \ref{rem:1-col tables}.  The idea then is that a column of $A$ with data type char(1) can be represented as a foreign key $A\to T_{\tn{char(1)}}$.  With this convention, both keys and data are represented in the same way.

\end{remark}

The following is a redrawing of the above diagram using arrows decorated with their ``meaning" rather than their source and target.  An arrow whose meaning is ``obvious" will be left unlabeled.  I will refer to the following as the ``dictionary pattern":

\begin{align}\tag{Dictionary Pattern}\label{dictionary pattern}\xymatrix@=1.2cm{&\tn{Table}\ar[rr]^{\tn{Name}}&&T_{\tn{String}}\\\tn{Row}\ar[ur]&&\tn{Column}\ar[ur]_{\tn{Name}}\ar[ul]\ar[rr]_{\;\tn{data\_type}} &&\DT\\&\tn{Cell}\ar[ul]\ar[ur]\ar[rrr]_{\tn{value}}&&&\U.\ar[u]_\pi}\end{align}

\section{Dictionary: Referential Integrity}

We now refer to slide 3 in Gates's deck.  We make the following changes: we drop the ``Schema" table for simplicity (although to include it is not hard) and we change the naming system as per Remark \ref{rem:naming arrows}.

\[\SelectTips{cm}{}\xymatrix@=1.7cm{T_{\tn{String}}\\&\tn{Table}\ar[ul]^<<<<<<{\tn{Name}}&\tn{Constraint}\ar[ull]_{\tn{Name}}\ar[l]\ar@(d,r)[]_{\tn{foreign\_refers\_to\_primary}}\ar[r]&\tn{Constraint Type}\ar[ulll]_{\tn{Name}}\\&\tn{Column}\ar[uul]^{\tn{Name}}\ar[u]&\tn{Cons\_Col}\ar[u]^{\tn{as\_source\_of}}\ar[l]_{\tn{source\_col}}}\]

\section{Refactoring}

We now refer to slide 6 in Gates's deck.  Again, we do not include the table called ``Schema" for simplicity.  We can draw this slide categorically as follows: $$\xymatrix@=2cm{T_{\tn{String}}\\&\tn{Table}\ar[ul]_{\tn{Name}}&\tn{Foreign Key}\ar[ull]_{\tn{Name}}\ar@/_1pc/[l]_>>>>>{\tn{source}}\ar@/^1pc/[l]^>>>>>{\tn{target}}\\&\tn{Column}\ar[u]\ar[uul]_{\tn{Name}}&\tn{Cons\_Col}\ar[l]\ar[u]}$$

\section{The categorical viewpoint}

In the paper [A simple model of databases], we assume that every table has a chosen primary key.  The idea of that paper is that a column representing pure data (e.g. a date-column or name-column) acts just like a foreign key column: we can think of such a column as a foreign key mapping to a 1-column table of data (e.g. just a date or just a name).  We call such a 1-column table a {\em terminal table}.  

We now write down this idea using two different representations: the usual schematic view and our graph view.

\begin{align}\tag{Usual schematic view}\xymatrix@=2cm{\mbox{\begin{tabular}{|l|}\hline Table\\\hline id\\primary\_id\\name\\\hline\end{tabular}\ar[rr]_{\tn{fk\_primary\_column}}}&&\mbox{\begin{tabular}{|l|}\hline Column\\\hline id\\source\_id\\target\_id\\name\\\hline\end{tabular}}\ar@/_2pc/[ll]_{\tn{fk\_source\_table}}\ar@/^2pc/[ll]^{\tn{fk\_target\_table}}}\end{align}

\begin{align}\tag{Categorical view}\xymatrix{&T_{\tn{String}}\\\\\tn{Table}\ar[uur]^{\tn{Name}}\ar[rr]_{\tn{primary}}&&\tn{Column}\ar@/_2pc/[ll]_{\tn{source}}\ar@/^2pc/[ll]^{\tn{target}}\ar[uul]_{\tn{Name}}}\end{align}

\subsection{Unnamed tables and columns}

Suppose we have a set of unnamed tables and a set of unnamed columns.  This would be represented graphically by the schema: $$\xymatrix{\tn{Table}\ar[rr]_{\tn{primary}}&&\tn{Column}\ar@/_2pc/[ll]_{\tn{source}}\ar@/^2pc/[ll]^{\tn{target}}}$$  Categorically, we demand that for any table $T$, the source of the primary column and the target of the primary column are both $T$.  Call this category $P$.

A database on this schema is a functor $P\to\Sets$.  It consists of a set of tables, a set of columns, for each table a primary column, and for each column both a source and a target table.  But whatever we call such a functor, it is the same as a reflexive graph.  In other words, a schema for a database is a reflexive graph.  

Each vertex represents a table.  Vertices that don't have outgoing arrows are ``terminal tables," representing pure data.  The identity arrow on a vertex represents its primary key, every other outgoing arrow is a foreign key (or, if its target is a terminal table, then it is pure data).  

\subsection{Conclusion}

A database as in Gates's deck is simply a reflexive graph with named nodes and named edges.  The difference between a reflexive graph and a category is simply the ability to declare that two different paths through the graph should result in the same output.  In other words, we can declare that transitively following one path of foreign keys from table $A$ to table $B$ will result in the same mapping as following a different path of foreign keys from $A$ to $B$.  See Diagram \ref{dia:commute} for an example of this.


\end{document}