\documentclass{amsart}

\usepackage{amssymb, amscd,stmaryrd,setspace,hyperref,color}

\input xy
\xyoption{all} \xyoption{poly} \xyoption{knot}\xyoption{curve}
\input{diagxy}


\newcommand{\comment}[1]{}

\newcommand{\longnote}[2][4.9in]{\fcolorbox{black}{yellow}{\parbox{#1}{\color{black} #2}}}
\newcommand{\note}[1]{\fcolorbox{black}{yellow}{\color{black} #1}}
\newcommand{\q}[1]{\begin{question}#1\end{question}}
\newcommand{\g}[1]{\begin{guess}#1\end{guess}}

\def\tn{\textnormal}
\def\mf{\mathfrak}
\def\mc{\mathcal}

\def\ZZ{{\mathbb Z}}
\def\QQ{{\mathbb Q}}
\def\RR{{\mathbb R}}
\def\CC{{\mathbb C}}
\def\AA{{\mathbb A}}
\def\PP{{\mathbb P}}
\def\NN{{\mathbb N}}

\def\Hom{\tn{Arr}}
\def\Fun{\tn{Fun}}
\def\Ob{\tn{Ob}}
\def\Op{\tn{Op}}

\def\to{\rightarrow}
\def\from{\leftarrow}
\def\cross{\times}
\def\taking{\colon}
\def\inj{\hookrightarrow}
\def\surj{\twoheadrightarrow}
\def\too{\longrightarrow}
\def\tooo{\longlongrightarrow}
\def\tto{\rightrightarrows}
\def\ttto{\equiv\!\!>}
\def\ss{\subset}
\def\superset{\supset}
\def\iso{\cong}
\def\down{\downarrow}
\def\|{{\;|\;}}
\def\m1{{-1}}
\def\op{^\tn{op}}
\def\loc{\tn{loc}}
\def\la{\langle}
\def\ra{\rangle}
\def\wt{\widetilde}
\def\wh{\widehat}
\def\we{\simeq}
\def\ol{\overline}
\def\ul{\underline}
\def\qeq{\mathop{=}^?}

\def\ullimit{\ar@{}[rd]|(.3)*+{\lrcorner}}
\def\urlimit{\ar@{}[ld]|(.3)*+{\llcorner}}
\def\lllimit{\ar@{}[ru]|(.3)*+{\urcorner}}
\def\lrlimit{\ar@{}[lu]|(.3)*+{\ulcorner}}
\def\ulhlimit{\ar@{}[rd]|(.3)*+{\diamond}}
\def\urhlimit{\ar@{}[ld]|(.3)*+{\diamond}}
\def\llhlimit{\ar@{}[ru]|(.3)*+{\diamond}}
\def\lrhlimit{\ar@{}[lu]|(.3)*+{\diamond}}
\newcommand{\clabel}[1]{\ar@{}[rd]|(.5)*+{#1}}

\newcommand{\arr}[1]{\ar@<.5ex>[#1]\ar@<-.5ex>[#1]}
\newcommand{\arrr}[1]{\ar@<.7ex>[#1]\ar@<0ex>[#1]\ar@<-.7ex>[#1]}
\newcommand{\arrrr}[1]{\ar@<.9ex>[#1]\ar@<.3ex>[#1]\ar@<-.3ex>[#1]\ar@<-.9ex>[#1]}
\newcommand{\arrrrr}[1]{\ar@<1ex>[#1]\ar@<.5ex>[#1]\ar[#1]\ar@<-.5ex>[#1]\ar@<-1ex>[#1]}

\newcommand{\To}[1]{\xrightarrow{#1}}
\newcommand{\Too}[1]{\xrightarrow{\ \ #1\ \ }}
\newcommand{\From}[1]{\xleftarrow{#1}}

\newcommand{\Adjoint}[4]{\xymatrix@1{#2 \ar@<.5ex>[r]^-{#1} & #3 \ar@<.5ex>[l]^-{#4}}}

\def\id{\tn{id}}
\def\Top{{\bf Top}}
\def\Cat{{\bf Cat}}
\def\Str{{\bf Str}}
\def\Sets{{\bf Sets}}
\def\Set{{\bf Set}}
\def\sSet{{\bf sSet}}
\def\sSets{{\bf sSets}}
\def\Grpd{{\bf Grpd}}
\def\Pre{{\bf Pre}}
\def\Shv{{\bf Shv}}
\def\Rings{{\bf Rings}}

\def\colim{\mathop{\tn{colim}}}

\def\mcA{\mc{A}}
\def\mcB{\mc{B}}
\def\mcC{\mc{C}}
\def\mcD{\mc{D}}
\def\mcE{\mc{E}}
\def\mcF{\mc{F}}
\def\mcG{\mc{G}}
\def\mcH{\mc{H}}
\def\mcI{\mc{I}}
\def\mcJ{\mc{J}}
\def\mcK{\mc{K}}
\def\mcL{\mc{L}}
\def\mcM{\mc{M}}
\def\mcN{\mc{N}}
\def\mcO{\mc{O}}
\def\mcP{\mc{P}}
\def\mcQ{\mc{Q}}
\def\mcR{\mc{R}}
\def\mcS{\mc{S}}
\def\mcT{\mc{T}}
\def\mcU{\mc{U}}
\def\mcV{\mc{V}}
\def\mcW{\mc{W}}
\def\mcX{\mc{X}}
\def\mcY{\mc{Y}}
\def\mcZ{\mc{Z}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{fact}[theorem]{Fact}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{warning}[theorem]{Warning}
\newtheorem{question}[theorem]{Question}
\newtheorem{guess}[theorem]{Guess}
\newtheorem{answer}[theorem]{Answer}
\newtheorem{construction}[theorem]{Construction}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{postulate}[theorem]{Postulate}

\def\Finm{{\bf Fin_{m}}}
\def\El{{\bf El}}
\def\Gr{{\bf Gr}}
\def\DT{{\bf DT}}
\def\DB{{\bf DB}}
\def\Tables{{\bf Tables}}
\def\Sch{{\bf Sch}}
\def\Fin{{\bf Fin}}
\def\P{{\bf P}}
\def\SC{{\bf SC}}
\def\ND{{\bf ND}}
\def\Poset{{\bf Poset}}
\def\'{\textnormal{'}}

%%%%%

\begin{document}

\title{Categories for informatics}

\author{David I. Spivak}

\thanks{Thanks to Tristan Nguyen and the ONR for the grant: N000140910466.}

\maketitle

\tableofcontents

\section{Introduction}

\begin{definition} We define {\em information} to be anything that can be expressed purely in strings of symbols, given a convention.  Dually, a {\em convention} is that which provides context so that certain strings of symbols can convey information.  

\end{definition}

It would be nice to have a grammar with which to specify a convention, but I would suspect that this cannot be done justice.

\subsection{Informatics}

Informatics is the study of information and its expression.  An expression $E$ is always created by an individual $A$ having a convention $C_A$ and with the intent to transmit information to an individual or group $B$, known by its convention $C_B$.

What is communicated in the number $1$, given the standard mathematical convention?  What is expressed in the symbols \begin{align}\label{ex:abelian}(x,y)\in A\cross A \tn{ where } A=\la+,-,0\ra\tn{ is an abelian group and } x+2y=0\end{align} given this convention?  If the author is $A$ and the reader is $B$, that which has been communicated in  Expression (\ref{ex:abelian}) can serve as an example of information and hence allow the reader to witness an example of the author's convention.

\subsection{Purpose of this paper}

In this paper, I will attempt to communicate about information using category theory and about category theory using examples from informatics.  More concretely, I will first define categories and functors.  I will then give many examples of them using well-known ideas from information science, such as databases and ontologies.

The mathematician may hope to be reminded of why we study databases, and the informatician may hope to be reminded why we might spend time learning category theory.  The first is easier.  Since information can be communicated in symbols, it can be made tangible and stored in computers.  In order to study it, we should examine that which we have currently have stored and in particular the symbolic forms in which it is currently stored.  

The author's preferred storage devices are currently categorical databases.  While these have not been implemented on computers, there exists a convention within which they can be communicated in symbols -- the authors'.  

The database practitioner and working ontologist might be interested to learn category theory for the same reason people tend to appreciate what little math they do know: Mathematics, and category theory in particular, is currently humanity's best language for conveying information rigorously and precisely.  

\section{What is category theory about}

Category theory is perhaps an undefined term, but it certainly involves the language of ``categories and functors."  Roughly, a category is a (possibly infinite) database schema, and a functor is data on that schema.  This connection will be made precise in Definitions \ref{def:schema} and \ref{def:database}.

\begin{definition}

A {\em graph} is a tuple $\mcG:=\la\Ob_\mcG,\Hom_\mcG,s_\mcG,t_\mcG\ra$, where $\Ob_\mcG$ and $\Hom_\mcG$ are sets, and $s_\mcG\taking\Hom_\mcG\to\Ob_\mcG$ and $t_\mcG\taking\Hom_\mcG\to\Ob_\mcG$ are total functions.  We express this by the diagram of sets $$\xymatrix{\Ob_\mcG&&\Hom_\mcG\ar@/_1pc/[ll]_{s_\mcG}\ar@/^1pc/[ll]^{t_\mcG}.}$$  The elements of $\Ob_\mcG$ are called the {\em objects} of $\mcG$, and the elements of $\Hom_\mcG$ are called the {\em arrows} of $\mcG$.  The function $s_\mcG$ is called the {\em source} and the function $t_\mcG$ is called the {\em target}, and for an arrow $f\in\Hom_\mcG$, we refer to $s(f)$ as the {\em source of $f$} and $t(f)$ as the {\em target of $f$}.

\end{definition}

The following constitutes the definition of a related concept, where instead of using the conventions of category theory, we do our best to emulate database convention.

\begin{definition}

A {\em named graph} is that which can be expressed within the database schema, \begin{align}\xymatrix@=2cm{{\begin{tabular}{| l |} \hline Node\\\hline id\\name\\\hline\end{tabular} }&&{\begin{tabular}{| l |} \hline Arrow\\\hline id\\source node\\target node\\name\\\hline\end{tabular}}\ar@/_1pc/[ll]_{\tn{source}}\ar@/^1pc/[ll]^{\tn{target}}}\end{align}

\end{definition}

\begin{definition}

A {\em named reflexive graph} is that which can be expressed within the database schema, \begin{align}\xymatrix@=2cm{{\begin{tabular}{| l |} \hline Node\\\hline id\\primary arrow\\name\\\hline\end{tabular} }\ar[rr]^{\tt{primary}}&&{\begin{tabular}{| l |} \hline Arrow\\\hline id\\source node\\target node\\name\\\hline\end{tabular}}\ar@/_2pc/[ll]_{\tt{source}}\ar@/^2pc/[ll]_{\tt{target}}}\end{align} under the constraint that $$ N{\tt.primary.source}=N{\tt.primary.target}=N$$ for all nodes $$N=\la N.{\tt id}, N.{\tt primary}, N{\tt .name}\ra.$$

\end{definition}

\begin{definition}

A {\em reflexive graph} is a tuple $\mcG:=\la\Ob_\mcG,\Hom_\mcG,p_\mcG,s_\mcG,t_\mcG\ra$ where $\Ob_\mcG$ and $\Hom_\mcG$ are sets, and $p_\mcG\taking\Ob_\mcG\to\Hom_\mcG, s_\mcG\taking\Hom_\mcG\to\Ob_\mcG,$ and $t_\mcG\taking\Hom_\mcG\to\Ob_\mcG$ are total functions such that $$s_\mcG\circ p_\mcG(X)=t_\mcG\circ p_\mcG(X)=X$$ for any element $X\in\Ob_\mcG$.  We express this by the diagram of sets $$\xymatrix{\Ob_\mcG\ar[rr]^{p_\mcG}&&\Hom_\mcG\ar@/_1.5pc/[ll]_{s_\mcG}\ar@/^1.5pc/[ll]_{t_\mcG}.}$$
\end{definition}

\begin{definition}

A {\em categorical database schema} is that which can be expressed within the following database schema. \begin{align}\xymatrix@=2cm{{\begin{tabular}{| l |} \hline Table\\\hline id\\primary key column\\name\\\hline\end{tabular} }\ar[rr]^{\tn{primary key}}&&{\begin{tabular}{| l |} \hline Column\\\hline id\\source table\\foreign referent table\\name\\\hline\end{tabular}}\ar@/_2pc/[ll]_{\tn{source}}\ar@/^2pc/[ll]_{\tn{foreign referent}}}\end{align}

\end{definition}

Clearly, categorical databases and named reflexive graphs have isomorphic schemas.  Thus we can make the following mathematical definition:

\begin{definition}\label{def:database}

A {\em database schema} $\mcD$ consists of a reflexive graph $G$ and a functor $\delta\taking G\to\Sets.$  We call $G$ the {\em schema} of $\mcD$ and we call $\delta$ the {\em data} of $\mcD$. 

\end{definition}



\begin{example}

Here is an example of a database schema, expressed as in Definition \ref{def:database}.

\end{example}

\begin{definition}

A {\em categorical database} is that which can be expressed within the following database schema.  \begin{align}\xymatrix@=2cm{{\begin{tabular}{| l |}\hline\multicolumn{1}{| c |}{TABLE}\\\hline id\\primary\_key\_column\\name\\\hline\end{tabular}}\ar[rr]^{\tt{primary\_key\_column}}&&{\begin{tabular}{| l |}\hline \multicolumn{1}{| c |}{COLUMN}\\\hline id\\source\_table\\value\_table\\name\\\hline\end{tabular}}\ar@/_2pc/[ll]_{\tt{source\_table}}\ar@/^2pc/[ll]_{\tt{value\_table}}\\{\begin{tabular}{| l |}\hline \multicolumn{1}{| c |}{ROW}\\\hline id\\source\_table\\primary\_key\_cell \\\hline\end{tabular}}\ar[u]_{\tt{source\_table}}\ar[rr]^{\tt{primary\_key\_cell}}&&{\begin{tabular}{| l |}\hline \multicolumn{1}{| c |}{CELL}\\\hline id\\source\_column\\source\_row\\value\_row\\\hline\end{tabular}}\ar[u]_{\tt{source\_column}}\ar@/_2pc/[ll]_{\tt{source\_row}}\ar@/^2pc/[ll]_{\tt{value\_row}}} \end{align} subject to the following constraints for all $T\in\tn{TABLE}, R\in\tn{ROW}, C\in\tn{CELL}$: \begin{align}&T{\tt.primary\_key\_column.source\_table}=T\\&T{\tt.primary\_key\_column.target\_table}=T\\&R{\tt.primary\_key\_cell.source\_row}=R\\&R{\tt.primary\_key\_cell.current\_value.value\_row}=R\\&C{\tt.source\_column.source\_table}=C{\tt.source\_row.source\_table}\\&C{\tt.value\_row.source\_table}=C{\tt.source\_column.value\_table}\end{align} and that \begin{align}\pi_{\tt{id,source\_column,source\_row}}(\tn{CELL})=\tn{COLUMN}\Join_{{\tt source\_table}={\tt source\_table}}\tn{ROW}\end{align}

\end{definition}



\longnote{Talk about composition using joins of tables}

\section{Examples from Informatics}

In this section we define other things from informatics in terms of categories.

\subsection{RDF}

\subsection{Context free grammars}



\end{document}