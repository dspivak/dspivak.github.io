\documentclass{amsart}

\input{decl-db}

\def\DT{{\bf DT}}
\def\GD{{\bf GD}}
\def\DB{\GD}
\def\Sch{{\bf Sch}}
\def\Null{{\bf Null}}
\def\Strings{{\bf Strings}}
\def\ND{{\bf ND}}
\def\Tables{{\bf Tables}}
\def\'{\tn{'}}
\def\disunion{\amalg}
\def\Rel{{\bf Rel}}
\def\mcRel{{\bf \mcR el}}
\def\Cech{$\check{\tn{C}}$ech }
\def\C{\check{\tn{C}}}
\def\Fin{{\bf Fin}}
\def\singleton{\{*\}}
\def\Sub{{\bf Sub}}
\def\card{\tn{card}}
\def\Data{{\bf DB}}
\def\im{\tn{im}}

%\usepackage{showkeys}

\begin{document}

\author{David I. Spivak}

\thanks{This project was supported in part by the Office of Naval Research.}

\title{Simplicial Databases}

\maketitle

\begin{abstract}

In this paper, we define a category $\Data$, called the category of simplicial databases, whose objects are databases and whose morphisms are data-preserving maps.  Along the way we give a precise formulation of the category of relational databases, and prove that it is a full subcategory of $\Data$.  We also prove that colimits and limits always exist in $\Data$ and that they correspond to queries such as select, join, union, etc.

One feature of our construction is that the schema of a simplicial database has a natural geometric structure, an underlying simplicial set.  The geometry of a schema is a way of keeping track of relationships between distinct tables, and can be thought of as a system of foreign keys.  The shape of a schema is generally intuitive (e.g. the schema for round-trip flights is a circle consisting of an edge from $A$ to $B$ and an edge from $B$ to $A$), and as such, may be useful for analyzing data.

We give several applications of our approach, as well as possible advantages it has over the relational model.  We also indicate some directions for further research.

\end{abstract}

\setcounter{tocdepth}{1}

\tableofcontents


\section{Introduction}\label{sec:intro}


The theory of relational databases is generally formulated within mathematical logic.  We provide a more modern and more flexible approach using category theory.  Category theory is a powerful language for formulating many aspects of computer science, and databases is no exception.  Using an inefficient language can hamper ones ability to implement, work with, and reason about a subject.  This can be seen as the reason that SQL implements tables, rather than relational databases in their pure form: mathematical logic is not a sufficiently flexible language for discussing databases as used in practice.

One reason that relational databases have been so successful is that their definition can be phrased within a precise mathematical language.  The definition we provide in this paper is just as precise, if not more so (see the discussion at the beginning of Section \ref{sec:schemas and databases}).  However, we go beyond simply defining the {\em objects} of study (databases), but instead continue on to define {\em morphisms} between databases.  With these definitions, we have a category of databases.

There are many categories whose objects are databases (the difference being in their morphisms); what makes one definition better than another?  First, a good definition should make sense -- the morphisms should somehow preserve the structure of the databases (see Remark \ref{rem:data integrity}).  Second, applying common categorical constructions (products, colimits, etc.) to the category of databases should result in common database constructions, such as unions, joins, etc. (see Section \ref{sec:constructions for databases}).  Third, the categorical approach should make reasoning about databases easier (see Section \ref{sec:applications}).  

Our formulation accomplishes these three goals.  As an added bonus, the schemas for our databases have geometric structure (more precisely, the structure of a simplicial set).  In other words, the schema is given as a geometric object which one should think of as a kind of Entity-Relationship diagram for the schema.  This approach may lead to improvements in query optimization because one can adjust the ``shape" of the schema to fit with the purposes of the queries to be taken.

Other researchers have formulated databases in terms of category theory (for example, see \cite{RW},\cite{JRW},\cite{PS},\cite{Ber},\cite{DK},\cite{Dis},\cite{GB}).  Of note is work by Cadish and Diskin, and work by Rosebrugh and Wood.  There are many differences between previous viewpoints and our own.  While our work uses category theory, it does not require much background there (see the next paragraph); past work tends to rely on ideas like sketches, fibrations of categories, and more obscure constructions such as institutions and equipments.  These are not too difficult, but take time to learn.  Second, although graphs have been used in past research to model schemas, our work uses simplicial sets (which are like higher-dimensional graphs) to model more complex relationships in a visual way.  

We assume throughout this paper that the reader has a basic knowledge of category theory which includes knowing the definition of category, functor, limit, and colimit.  Good references for this material include \cite{Mac},\cite{BW}, and \cite{Bor1}.  We do not assume that the reader has a prior knowledge of simplicial sets.

We begin by defining a category, called the category of tables, in Section \ref{sec:tables}.  In Section \ref{sec:constructions for tables}, we prove that the category of tables is closed under limits and certain colimits, and that these constructions give joins unions.  We also prove that projections and deletions are easily defined under our formulation.  In Section \ref{sec:schemas and databases}, we first give a brief description of (symmetric) simplicial sets.  We then proceed to define the category of simplicial databases.  In Section \ref{sec:constructions for databases}, we prove that the category of geometric databases is closed under all limits and colimits and prove that they have sensible meanings in terms of database theory.  Finally in Section \ref{sec:applications}, we discuss applications of our model and directions for future research.

\subsection{Acknowledgments}

I would like to thank Paea LePendu for explaining relational databases to me, for suggesting that databases should be categorified, and for his advice and encouragement throughout the process.  I would also like to thank Chris Wilson for several useful conversations.

\section{The category of Tables}\label{sec:tables}

It is no accident that SQL uses tables instead of relations: Tables are inherently more useful and easier to implement.  They are disliked by the purists of relational database theory not because they are bad, but because they do not fit in with that theory.  In this section we provide a categorical structure to the set of tables, thus firmly grounding it in rigorous mathematics.  

\subsection{Data types}

In order to define schemas, records, and tables of a given type, we need to define what we mean by ``type." 

\begin{definition}

A {\em type designation} is simply a function between sets $\pi\taking U\to \DT$.  The set $\DT$ is called the set of {\em data types} for $\pi$, and the set $U$ is called the {\em domain bundle} for $\pi$.  Given any element $T\in\DT$, the preimage $\pi^\m1(T)\ss U$ is called the {\em domain of $T$}, and an element $x\in\pi^\m1(T)$ is called an {\em object of type $T$}.

\end{definition}

\begin{example}\label{ex:type designation}

Let $U$ denote the disjoint union $U:=(\ZZ\amalg\RR\amalg\Strings)$ and let $\DT$ denote the three element set $\{`\ZZ\', `\RR\', `\Strings\'\}$.  Let $\pi\taking U\to\DT$ denote the obvious function, which send all of $\ZZ$ to the element $`\ZZ\'$, all of $\RR$ to $`\RR\'$, and all of $\Strings$ to $`\Strings\'$. 
The preimage $\pi^\m1(`\Strings\')\ss U$, which we have called the domain of $`\Strings\'$, is indeed the set of strings.

As another example, the mod 2 function $\pi\taking\ZZ\to\{\tn{`even'},\tn{`odd'}\}$ is a type designation in which the objects of type `even' are the even integers.

\end{example}

\subsection{Schemas}

We quickly recall the definition of fiber product (for sets).

\begin{definition}

Let $A, B,$ and $C$ be sets, and suppose $f\taking A\to B$ and $g\taking C\to B$ are functions with the same codomain.  The {\em fiber product of $A$ and $C$ over $B$}, denoted $A\cross_BC$ is the set $$A\cross_BC:=\{(a,c)\in A\cross C | f(a)=g(c)\in B\}.$$  The fiber product moreover comes equipped with obvious projection maps making the diagram $$\xymatrix{A\cross_BC\ar[r]^{f'}\ar[d]_{g'}\ullimit&C\ar[d]^g\\A\ar[r]_f&B}$$ commute.  The corner symbol $\lrcorner$ serves to remind the reader that the object in the upper left is a fiber product.   We sometimes call $g'\taking A\cross_BC\to A$ the {\em pullback of $g$ along $f$}; similarly $f'$ is the pullback of $f$ along $g$.

\end{definition}

\begin{remark}

The fiber product of the diagram $A\To{f}B\From{g}C$ above should probably be denoted $f\cross_Bg$ instead of $A\cross_BC$, since it depends on the maps $f$ and $g$, not just their domains.  However, this is not often done, and in this paper the maps will be clear from context.

\end{remark}

\begin{definition}\label{def:simple schema}.

Let $\pi\taking U\to\DT$ denote a type designation.  A {\em simple schema of type $\pi$} consists of a pair $(C,\sigma)$, where $C$ is a finite set and $\sigma\taking C\to\DT$ is a function.   We often refer to a simple schema simply as a {\em schema}.  We sometimes denote the schema $(C,\sigma)$ simply by $\sigma$.  We refer to $C$ as the set of {\em attributes} for $\sigma$ and $\pi$ as the {\em type designation} for $\sigma$.

We call the pullback $\pi_\sigma\taking\sigma^\m1(U)\to C$, i.e. the left hand map in the diagram $$\xymatrix{\sigma^\m1(U)\ar[r]\ar[d]_{\pi_\sigma}\ullimit&U\ar[d]^\pi\\C\ar[r]_\sigma&\DT,}$$ the {\em domain bundle} induced by $\sigma$.  We sometimes write $U_\sigma$ to denote $\sigma^\m1(U)$.

\end{definition}

\begin{example}\label{ex:schema}

Let $\pi\taking U\to\DT$ denote the type designation of Example \ref{ex:type designation}.  Let $C=\{\tn{`First Name', `Last Name',`Age'}\}$, and define $\sigma\taking C\to\DT$ by \begin{align*}\sigma(\tn{`First Name'})&=`\Strings\'\\\sigma(\tn{`Last Name'})&=`\Strings\'\\\sigma(\tn{`Age'})&=`\ZZ'\end{align*}    It should be clear why $C$ is called the set of attributes and $\sigma$ the schema.

The domain bundle $U_\sigma$ induced by $\sigma$ is the obvious function $$(\Strings\amalg\Strings\amalg\ZZ)\too C.$$  Thus the set of objects of type `First Name' is the set of strings, in this example.

\end{example}

\begin{definition}\label{def:category of schema}

Let $\pi\taking U\to\DT$ denote a type designation.  A {\em morphism of simple schemas (of type $\pi$)}, written $f\taking (C,\sigma)\to (C',\sigma')$, is a function $f\taking C\to C'$ such that the triangle $$\xymatrix@=16pt{C\ar[rr]^f\ar[dr]_\sigma&&C'\ar[dl]^{\sigma'}\\&\DT}$$ commutes.

The {\em category of simple schemas on $\pi$}, denoted $\mcS^\pi$ is the category whose objects are simple schemas and whose morphisms are morphisms thereof.  

\end{definition}

\begin{remark}

Let $(\Fin\down\DT)$ denote the category for which an object is a finite set with a map to $\DT$ and for which a morphism is a function from one finite set to another, over $\DT$.  One can easily see that the category $\mcS^\pi$ is isomorphic to $(\Fin\down\DT)$, regardless of $\pi$.  However, we should think of $\pi$ as part of the data for a schema.  

\end{remark}

\subsection{Records and Tables}

\begin{definition}\label{def:records}

Let $(C,\sigma)$ be a schema.  A {\em record on $(C,\sigma)$} is a function $r\taking C\to U_\sigma$ such that $\pi_\sigma\circ r=\id_C$, i.e. a section of the domain bundle for $\sigma$.  We denote the set of records on $\sigma$ by $\Gamma^\pi(\sigma)$, or simply by $\Gamma(\sigma)$ if $\pi$ is understood.

\end{definition}

In other words, a record must produce, for each attribute $c\in C$, an object of type $\sigma(c)\in\DT$.  

\begin{example}\label{ex:record}

Let $\pi$ and $(C,\sigma)$ be as in Example \ref{ex:schema}.  A record on that schema is a section $r$ as depicted in the diagram $$\xymatrix{\Strings\amalg\Strings\amalg\ZZ\ar[d]^{\pi_\sigma}\\\{\tn{`First Name', `Last Name',`Age'}\}.\ar@/^1pc/[u]^r}$$  That is, a record is a way to designate a first name and a last name (in $\Strings$) and an age (in $\ZZ$).  For example (Barack; Obama; 48) denotes a record of this schema; that is it defines a section of $\pi_\sigma$.

The set $\Gamma(\sigma)$ of records on $(C,\sigma)$ is simply the set of all possible such designations.  In this example $\Gamma(\sigma)=\Strings\cross\Strings\cross\ZZ$.

\end{example}

\begin{definition}\label{def:tables}

Let $\pi\taking U\to\DT$ be a type designation.  A {\em table of type $\pi$} consists of a sequence $(K,C,\sigma,\tau)$, where $K$ is a finite set, $(C,\sigma)$ is a schema of type $\pi$,  and $\tau\taking K\to\Gamma(\sigma)$ is a function.  We sometimes denote $(K,C,\sigma,\tau)$ simply by $\tau$.  The set $K$ is called the {\em set of keys of $\tau$}, and $(C,\sigma)$ is called the {\em schema of $\tau$}.

\end{definition}

\begin{example}\label{ex:table}

Given a schema $(C,\sigma)$, a table on that schema is simply a collection of records indexed by a set $K$.  The records need not be distinct because the set $K$ keeps track of the distinctions.  Continuing with $\pi$ and $(C,\sigma)$ as in Example \ref{ex:record}, we could have $K=\{1,2,`foo'\}$ and let $\tau\taking K\to\Gamma(\sigma)$ be the assignment \begin{align*} 1&\mapsto \tn{(Barack; Obama; 48)}\\2&\mapsto \tn{(Michelle; Obama; 45)}\\ `foo'&\mapsto\tn{(Barack; Obama; 48)}\end{align*}

\end{example}

\begin{lemma}\label{induced morphisms}

Let $\pi\taking U\to\DT$ denote a type designation, let $(C_1,\sigma_1)$ and $(C_2,\sigma_2)$ denote schemas on $\pi$, and let $f\taking (C_2,\sigma_2)\to (C_1,\sigma_1)$ denote a morphism of schemas.  There is an induced map on record sets $f^*\taking \Gamma(\sigma_1)\to\Gamma(\sigma_2)$.

\end{lemma}

\begin{proof}

Consider the diagram $$\xymatrix{\sigma_2^\m1(U)\ar[r]\ar[d]_{\pi_2}\ullimit &\sigma_1^\m1(U)\ar[r]\ar[d]_{\pi_1}\ullimit&U\ar[d]_\pi\\C_2\ar[r]^f\ar@/_1pc/[rr]_{\sigma_2}&C_1\ar[r]^{\sigma_1}&\DT.}$$  Note that the left hand square is a fiber product square.  This follows from the fact that the right hand square and the big rectangle are fiber product squares.  We must show that a section $r_1\taking C_1\to \sigma_1^\m1(U)$ of $\pi_1$ induces a section $r_2\taking C_2\to\sigma_2^\m1(U)$ of $\pi_2$, because this assignment will constitute $f^*\taking\Gamma(\sigma_1)\to\Gamma(\sigma_2)$.

Suppose given $r_1$ with $\pi_1\circ r_1=\id_{C_1}$.   We have a map $r_1\circ f\taking C_2\to\sigma_1^\m1(U)$ and a map $\id_{C_2}\taking C_2\to C_2$ such that $f\circ\id_{C_2}=f=\pi_1\circ(r_1\circ f)$.  By the universal property, these two maps define a map $r_2\taking C_2\to\sigma_2^\m1(U)$ such that, in particular $\pi_2\circ r_2=\id_{C_2}$.  This is the desired section of $\pi_2$.

\end{proof}

Given a morphism $f$ of schema, the function $f^*$ defined in the above lemma is said to be {\em induced} by $f$.

\begin{definition}\label{def:morphism of tables}

Let $\pi\taking U\to\DT$ be a type designation, and let $(K_1,C_1,\sigma_1,\tau_1)$ and $(K_2,C_2,\sigma_2,\tau_2)$ denote tables.  A {\em morphism of tables} $\varphi\taking\tau_1\to\tau_2$ consists of a pair $(g,f)$, where $g\taking K_1\to K_2$ is a function and $f\taking (C_2,\sigma_2)\to(C_1,\sigma_1)$ is a morphism of schema such that the diagram of sets \begin{align}\label{dia:morphism of tables}\xymatrix{K_1\ar[r]^{\tau_1}\ar[d]_g&\Gamma(\sigma_1)\ar[d]^{f^*}\\K_2\ar[r]_{\tau_2}&\Gamma(\sigma_2)}\end{align} commutes, where $f^*\taking\Gamma(\sigma_1)\to\Gamma(\sigma_2)$ is the function induced by $f$.

\end{definition}

\begin{example}\label{ex:morphism of tables}

Let us continue with Example \ref{ex:table}, with $\sigma_1$ and $(K_1,\tau_1)$ as in that example.  Let $C_2=\{\tn{`First', `Last'}\}$ and let $\sigma_2$ send both elements to the data type $\Strings\in\DT$; thus $\Gamma(C_2)=\Strings\cross\Strings$.  

Let $K_2=\{5,6,`baz'\}$ and $\tau_2$ be the assignment \begin{align*}5&\mapsto \tn{(Barack; Obama)}\\6 &\mapsto\tn{(Michelle; Obama)}\\`baz' &\mapsto\tn{(George; Bush)}.\end{align*}  

A morphism of tables $\varphi\taking\tau_1\to\tau_2$ should consist of a map $g\taking K_1\to K_2$ and a map $f^*\taking\Gamma(C_1)\to\Gamma(C_2)$.   We have an obvious map of schema $f\taking C_2\to C_1$, namely $\tn{`First'}\mapsto\tn{`First name'}$ and $\tn{`Last'}\mapsto\tn{`Last name'}$.  Then $f^*\taking\Gamma(\sigma_1)\to\Gamma(\sigma_2)$ is just the projection $\Strings\cross\Strings\cross\ZZ\to\Strings\cross\Strings$.

Now, to define a morphism of tables $\varphi\taking\tau_1\to\tau_2$, our choice of $g$ must send the record $(\tn{Barack; Obama;48})$ to the record $(\tn{Barack; Obama})$ and the record $(\tn{Michelle; Obama; 45})$ to $(\tn{Michelle; Obama})$.  

\end{example}

\begin{remark}\label{rem:table integrity}

The morphism of tables in Example \ref{ex:morphism of tables} is fairly general.  Generally, a morphism of tables may include a projection (in the columns) together with an inclusion (in the rows).  The requirement that the square (\ref{dia:morphism of tables}) in Definition \ref{def:morphism of tables} commutes is simply the requirement that morphisms preserve the integrity of the data.

\end{remark}

\subsection{The category of tables}

We have now defined tables and morphisms between tables.  Given morphisms depicted $$\xymatrix{K_1\ar[d]\ar[r]^{\tau_1}&\Gamma(\sigma_1)\ar[d]\\K_2\ar[d]\ar[r]^{\tau_2}&\Gamma(\sigma_2)\ar[d]\\K_3\ar[r]^{\tau_3}&\Gamma(\sigma_3)}$$ it is easy to see how composition is defined.  It is also easy to understand the identity morphism on a table $\tau\taking K\to\Gamma(C)$.  Thus we have a category.


\begin{definition}\label{def:tables}

Let $\pi\taking U\to\DT$ denote a type designation.  The category whose objects are tables $K\to\Gamma(\sigma)$ and whose morphisms are commutative squares as in Definition \ref{def:morphism of tables} is called {\em the category of tables on $\pi$} and is denoted $\Tables^\pi$, or simply $\Tables$ if $\pi$ is understood.

\end{definition}

\begin{example}

Suppose $\pi\taking U\to\DT$ is as in Example \ref{ex:schema}.  Suppose that $C=\{c_1,c_2\}$ and $C'=\{c_1'\}$, and that $\sigma$ and $\sigma'$ are the obvious maps such that $\Gamma(\sigma)=\ZZ\cross\ZZ$ and $\Gamma(\sigma')=\ZZ$.  Let $K$ and $K'$ be any two sets and $\tau\taking K\to\Gamma(\sigma)$ and $\tau'\taking K'\to\Gamma(\sigma')$ be any two tables.  

In the category of tables, we are allowed any kind of morphisms on key sets $K\to K'$, but the only permitted maps $\ZZ\cross\ZZ\too\ZZ$ are the two projections.

\end{example}

\begin{definition}

Let $\pi\taking U\to\DT$ denote a type designation and let $\sigma\taking C\to\DT$ denote a schema.  The {\em category of tables on $\sigma$}, denoted $\Tables^\pi_\sigma$ is the category whose objects are tables $\tau\taking K\to\Gamma(\sigma)$ and whose morphisms are triangles $$\xymatrix@=9pt{K_1\ar[drrr]^{\tau_1}\ar[dd]_f\\&&&\Gamma(\sigma)\\K_2\ar[urrr]_{\tau_2}}$$ denoted by $f$.  

\end{definition}

\subsection{Relational tables}

The most common formulation of databases used today is the relational model, invented by E.F. Codd (see \cite{Cod}).  It is based on the theory of mathematical logic, and more specifically relations.  One can find a modern treatment of the subject in \cite{Dat}.  We define a relation in Definition \ref{def:relational table} as a type of table, where we require that the map $\tau\taking K\to\Gamma(\sigma)$ be an injection.

\begin{definition}\label{def:relational table}

Let $\pi\taking U\to\DT$ denote a type designation, and let $\sigma\taking C\to\DT$ denote a schema on $\pi$.  A {\em relation on $\sigma$} is a table $\tau\taking K\to\Gamma(\sigma)$ for which $\tau$ is an injective function.  

A morphism of relations is a morphism of tables, for which the source and target tables are relations.  That is, the {\em category of relations}, denoted $\Rel^\pi$ is the full subcategory of $\Tables^\pi$ spanned by the relations.  Given a schema $\sigma$, the {\em category of relations on $\sigma$} is the full subcategory of $\Tables^\pi_\sigma$ spanned by the relations.  As usual the superscript $\pi$ can be dropped if it is understood.

There is a functor $\Rel\to\Tables$ and a functor $\Rel_\sigma\to\Tables_\sigma$, both of which are simply inclusions of full subcategories.

\end{definition}

\section{Constructions and formal properties of Tables}\label{sec:constructions for tables}

Our definition for the category of tables (Definition \ref{def:tables}) is sensible because objects are tables and morphisms are data-preserving maps.  In this section we show that category-theoretic operations on tables correspond to operations on databases, such as joins and other queries.  Fix a type designation $\pi\taking U\to\DT$ for the remainder of the section.

There is a forgetful functor $\Tables\to\Sets$ given by sending a table $K\to\Gamma(\sigma)$ to the key set $K$ and a morphism of tables to the underlying map of keys.  There is another forgetful functor $\Tables\to(\Fin\down\DT)\op$ which sends the above table to $\sigma$ and a morphism $\varphi=(g,f)$ of tables to the underlying morphism of schema $f$.

\begin{lemma}\label{final object}

There exists a final object and an initial object in $\Tables$.    

\end{lemma}

\begin{proof}

One checks immediately that if we take $K$ to be the terminal object in $\Sets$ and $\sigma$ to be the inital object $\emptyset\to\DT$ in $(\Fin\down\DT)$, then there is exactly one table with these as its underlying keys and schema, and this table is the terminal object in $\Tables$.

One also checks immediately that if we take $K=\emptyset$ to be the initial object in $\Sets$ and $\sigma=\id_{\DT}\taking\DT\to\DT$ to be the final object in $(\Fin\down\DT)$, then there is exactly one table with these as its underlying keys and schema, and this table is the initial object in $\Tables$.

\end{proof}

Certain colimits exist in $\Tables$; namely colimits of diagrams that are constant in the schema.

\begin{construction}

Let $\tau_1\taking K_1\to\Gamma(\sigma)$ and $\tau_2\taking K_2\to\Gamma(\sigma)$ be two tables with the same schema.  By taking the disjoint union of $K_1$ and $K_2$ we get a new table $\tau\taking K_1\amalg K_2\to\Gamma(\sigma)$.  This query is called {\em union all} in SQL.  

We can also take the (non-disjoint) union of these two tables, if we know how they overlap.  That is, if there is some set $K$ with maps $f_1\taking K\to K_1$ and $f_2\taking K\to K_2$ in such a way that $\tau_1\circ f_1=\tau_2\circ f_2$, then we can obtain a new table $\tau\taking K_1\amalg_KK_2\to\Gamma(\sigma)$.  This query is called {\em union} in SQL.

\end{construction}

We will see that limits in the category of tables correspond to generalized joins.

\begin{proposition}\label{finite limits exist}

All finite limits exist in $\Tables$.

\end{proposition}

\begin{proof}

It suffices to show that $\Tables$ has a terminal object and is closed under taking fiber products; the first of these was shown in Lemma \ref{final object}.  For the second, suppose we have a diagram \begin{align}\label{eqn:limit}\xymatrix{K_1\ar[d]\ar[r]^{\tau_1}&\Gamma(\sigma_1)\ar[d]^{f_1^*}\\K\ar[r]^\tau&\Gamma(\sigma)\\K_2\ar[r]^{\tau_2}\ar[u]&\Gamma(\sigma_2)\ar[u]_{f_2^*}}\end{align} in $\Tables$.  As indicated, the maps $\Gamma(\sigma_i)\to\Gamma(\sigma)$ are induced by morphisms of schema $f_i\taking\sigma\to\sigma_i$, for $i=0,1$.

Consider the schema $$(\sigma_1\amalg_\sigma\sigma_2)\taking C_1\amalg_CC_2\too\DT$$ induced by taking the colimit of the column sets.  Let us now show that it is the fiber product of the diagram of schema; i.e. that the function \begin{eqnarray}\label{eqn:limit schema}\Gamma(\sigma_1\amalg_\sigma\sigma_2)\too\Gamma(\sigma_1)\cross_{\Gamma(\sigma)}\Gamma(\sigma_2)\end{eqnarray} is a bijection.  

Let us first calculate the set $\Gamma(\sigma_1\amalg_\sigma\sigma_2)$.  It is the set of all sections $r$ of the map $\pi'$ in the diagram $$\xymatrix{(\sigma_1\amalg_\sigma\sigma_2)^\m1(U)\ullimit\ar[r]\ar[d]^{\pi'}&U\ar[d]^\pi\\C_1\amalg_CC_2\ar@{..>}@/^1pc/[u]^r\ar[r]_-{\sigma_1\amalg_\sigma\sigma_2}&\DT.}$$  To give such a section is to give, for each $c_1\in C_1$ an element of $\pi^\m1(\sigma_1(c_1))$, and for each $c_2\in C_2$ an element of $\pi^\m1(\sigma_2(c_2))$, in such a way that for all $c\in C$, the induced elements in $\pi^\m1(\sigma_i(f_i(c)))$ are the same for $i=1,2$.  This is precisely the data needed for a unique element of the set $\Gamma(\sigma_1)\cross_{\Gamma(\sigma)}\Gamma(\sigma_2)$, proving the claim that the map in (\ref{eqn:limit schema}) is a bijection.

Now we are ready to give the fiber product of Diagram (\ref{eqn:limit}).  It is the table $$K_1\cross_KK_2\too\Gamma(\sigma_1\amalg_\sigma\sigma_2).$$

\end{proof}

Proposition \ref{finite limits exist} produces the join of two tables over a third.  As one sees from the construction, the columns of the join are the union of the columns of the given tables, and the keys are the fiber product of the keys of the given tables.

\begin{lemma}

Let $\sigma\taking C\to\DT$ denote a schema.  The category $\Tables_\sigma$ of tables on $\sigma$ is closed under small limits and colimits.

\end{lemma}

\begin{proof}

The category of sets is closed under small limits and colimits.  To take the limit or colimit of a diagram in $\Tables_\sigma$, simply take the limit or colimit (respectively) of the underlying diagram of keys -- see Definition \ref{def:forgetful}.  This set comes with a natural map to $\Gamma(\sigma)$, and one shows easily that it is the limit or colimit (respectively) of the diagram of tables.

\end{proof}

\begin{example}\label{ex:initial and final over sigma}

Let $\sigma\taking C\to\DT$ denote a schema.  The initial and final objects in $\Tables_\sigma$ are $\emptyset\to\Gamma(\sigma)$ and $\id_{\Gamma(\sigma)}\taking\Gamma(\sigma)\to\Gamma(\sigma)$, respectively.

\end{example}

\begin{construction}

Let $\tau\taking K\to\Gamma(\sigma)$ be a table with schema $\sigma\taking C\to\DT$, and let $C'\ss C$ be a subset of its columns.  There is an induced table $\tau|_{C'}\taking K\to\Gamma(\sigma|_{C'})$.  In SQL this construction is called the {\em projection} of $\tau$ onto the subset $C'\ss C$ of columns.

\end{construction}

Using the projection query, one can realize a SELECT query as a limit of databases.  

\begin{construction}

Let us construct the SELECT query.  One begins with a table $\tau\taking K\to\Gamma(\sigma)$ with schema $\sigma\taking C\to\DT$, from which to select.  Let $f\taking C'\ss C$ be a subset of its columns, and let $\sigma'=\sigma|_{C'}\taking C'\to\DT$ be the restricted schema.  One may select from $\tau$ all records whose restriction to $C'$ is a member of some list.  We encode this list as a table $\tau'\taking K'\to\Gamma(\sigma')$ on $\sigma'$.  

In order to select from $\tau$ all records whose restriction to $C'$ in the table $\tau'$, take the limit of the diagram $$\xymatrix{K\ar[r]^\tau\ar[d]_{f^*\circ\tau}&\Gamma(\sigma)\ar[d]^{f^*}\\\Gamma(\sigma')\ar[r]^\id&\Gamma(\sigma')\\K'\ar[r]_{\tau'}\ar[u]^{\tau'}&\Gamma(\sigma').\ar[u]_{\id}}$$  This limit is the desired select query.

\end{construction}

We conclude this section by a quick remark on the category-theoretic properties of the relational tables.

\begin{remark}

Relations behave much like ordinary tables.  Limits exist in the $\Rel,$ colimits exist in the category $\Rel_\sigma$ of relations on a fixed schema $\sigma$.  The functor $\Rel\to\Tables$ preserves limits, and the functor $\Rel_\sigma\to\Tables_\sigma$ preserves limits but {\em does not} preserve colimits.

\end{remark}

\section{Schemas and databases}\label{sec:schemas and databases}

A relational database is a set of relations, together with a system of keys and foreign keys which link the relations together.  This is not a precise definition, and indeed a concise definition is not readily available, either in research papers or textbooks.  Most definitions one finds for relational databases are not rigorous -- they often use examples to suggest how the definition might go, without defining the concept directly.  There are exceptions, such as \cite[2.1]{RW}, but as far as we know, these definitions are not actually the ones used, either by practitioners or by theorists.  

In this section we will define simplicial databases in a rigorous way (see Definition \ref{def:database objects}).  Although examples will be plentiful, they will never stand in for precise definition.  We will also define morphisms of databases, thus making explicit the idea of ``data-preserving maps."  Providing a precise definition of the category of databases will surely be useful to database theorists, as well as to mathematicians interested in studying modern information theory.

\subsection{Schemas}\label{subsec:schemas}

Roughly, a simplicial set is a picture that can be drawn with vertices, edges, solid triangles, solid tetrahedra, and ``higher-dimensional tetrahedra."  For any integer $n\geq 0$, an $n$-dimensional solid tetrahedron, or {\em $n$-simplex}, is the shape in $\RR^{n+1}$ given by the algebraic equation $x_1+x_2+\cdots+x_{n+1}=1$ and the inequalities $x_i\geq 0$ for $1\leq i\leq n+1$.  To draw with these shapes is to connect various tetrahedra together along their faces (or subfaces).  For example, one could connect four triangles together along various faces to obtain an empty tetrahedron, the boundary of the 3-simplex.

Simplicial sets are a fundamental tool in algebraic topology, and are important in many other fields within mathematics, such as combinatorial commutative algebra.   See \cite{Fri} or \cite{GJ} for details.

A database is a system of tables which are connected together via foreign keys.  This information is part of the schema for the database.  We can keep track of this information using (something akin to) simplicial sets as our schema.  Tables are connected together when the corresponding simplices are connected.  

We use a slight variant of simplicial sets, which we will define in Definition \ref{}.  Let us briefly explain what requires this departure.  First, the simplices in a simplicial set have ordered vertices.  The columns of a table will correspond with the vertices of a simplex; we follow the convention in database theory in which columns are unordered.  We therefore must use a variant of simplicial sets, called the category of symmetric simplicial sets (see \cite{Gra}).

Furthermore, since columns can only take entries in a given data type, we must keep track of this information.  One way would be to consider simplicial sets whose vertices are each labeled with a data type.  This would work fine and is equivalent to our approach (see Remark \ref{rem:sch and fin}), which we will discuss shortly.  The reason we chose the approach we did was for future generalizations.

\begin{definition}\label{def:schema}

Let $\Fin$ denote the category of finite sets, let $\pi\taking U\to\DT$ be a type designation, and let $$\mcS\iso(\Fin\down\DT)$$ denote the category of simple schema on $\pi$ (see Definition \ref{def:simple schema}).  We define {\em the category of schema on $\pi$}, denoted $\Sch^\pi$ to be the category whose objects are functors $X\taking\mcS\op\to\Sets$ and whose morphisms are natural transformations of functors.

Let $X\in\Sch^\pi$ denote a schema.  Given a simple schema $\sigma\taking C\to\DT$, the {\em $\sigma$-simplices} of $X$ are the elements of the set $X(\sigma)$, and we write $X_\sigma$ to denote $X(\sigma)$.

\end{definition}

\begin{remark}\label{rem:sch and fin}

Given a category $\mcC$, the category whose objects are functors $\mcC\op\to\Sets$ and whose morphisms are natural transformations of functors is called {\em the category of presheaves on $\mcC$} and denoted $\Pre(\mcC)$.  It is a common mathematical construction which ``formally adds all colimits to $\mcC$."  That is, $\Pre(\mcC)$ is closed under taking colimits, and for any functor $\mcC\to\mcD$ to a category $\mcD$ which is closed under taking colimits, there is a unique colimit-preserving functor $\Pre(\mcC)\to\mcD$ over $\mcC$.  See \cite{}.

Thus, we have $\Sch^\pi=\Pre(\mcS^\pi)$.  Since $\mcS^\pi$ signifies the category of ways to set up columns of a tables, $\Pre(\mcS^\pi)$ is the category of ways to glue such things together.

\end{remark}

\begin{remark}\label{rem:symmetric}

The category of symmetric simplicial sets is the category $\Pre(\Fin)$.  The only difference between it and $\Pre(\mcS^\pi)\iso\Pre(\Fin\down\DT)$ is that each simplex in $\Sch^\pi$ has labeled vertices, whereas simplices in $\Pre(\Fin)$ do not.  In the introduction to this section we described symmetric simplicial sets in terms of tetrahedra.  After making the necessary modifications, we see that a schema is constructed by gluing together labeled tetrahedra along their faces, where we only allow these tetrahedra to be glued if their labels match.

If $X$ is a schema, we sometimes refer to the simplices of its underlying symmetric simplicial set as simplices of $X$.  Thus, the $n$-simplices of $X$ is the union of all $\sigma$-simplices of $X$, where $\sigma\taking C\to\DT$ is a simple schema with cardinality $\card(C)=n+1$.  That is, we write $$X_n=\coprod_{\{\sigma\taking C\to\DT| \card(C)=n+1\}}X_\sigma.$$  There is a classifying map $c\taking X_0=\left(\amalg_{a\in\DT}X_a\right)\to\DT$ which sends all of $X_a$ to $a$.

\end{remark}

One of the best features of the type of schema we are presenting here is their geometric nature, as described in the first paragraph of this section.  Unfortunately, Definition \ref{def:sch} does not make that explicit at all.  Hopefully the next few examples will help make the geometry more clear.

\begin{example}\label{ex:simplices}

Let $\sigma\taking C\to\DT$ denote a simple schema.  It naturally defines a schema $X=\Delta^\sigma$ as follows.  Given another simple schema $\sigma'\taking C'\to\DT$, let $X_{\sigma'}=\Hom_\mcS(\sigma',\sigma)$.  It is not immediately obvious what this schema should ``look like."  If $C$ has $n$ elements, one should imagine $\Delta^\sigma$ as an $(n-1)$-dimensional tetrahedron whose vertices are labeled by elements in the image of $\sigma$.

For example, suppose $C$ has two elements and their images under $\sigma$ are $a,b\in\DT$.  We imagine $\Delta^\sigma$ as a line segment whose vertices are labeled $a$ and $b$.  If $C'$ has three elements and $\sigma'$ sends two of them to $a$ and one of them to $b$, we imagine $\Delta^{\sigma'}$ as a filled-in triangle, whose vertices are labeled $a,a,$ and $b$. 

\end{example}

\begin{example}

We have mentioned that every object in $\Sch^\pi$ can be obtained by gluing together simplices.  This is proven in \cite[2.15.6]{Bor1}.  Let us explain how we would construct the union of two edges along a common node.  Suppose that the common node is labeled $b$ and the other nodes are labeled $a$ and $c$.  It is obtained as the colimit of the diagram $$\Delta^{\{a,b\}}\from\Delta^{\{b\}}\to\Delta^{\{b,c\}}$$ taken in $\Sch^\pi$.

We will now write down this schema explicitly as a functor $X\taking(\Fin\down\DT)\op\to\Sets$.  Given $\sigma\taking C\to\DT$, we let $X_\sigma$ be a single element if the image of $\sigma$ is contained in $\{a,b\}$ or contained in $\{b,c\}$.  

\end{example}

\begin{example}\label{ex:gluing}

We can make schemas whose shapes are things like circles, spheres, or triangles joined to other triangles.  For example one may choose to join two triangles along a common vertex or along a common edge, or along the entirety of their boundary.  Each of the resulting schema will be a simplicial set which has a unique label in $\DT$ assigned to each vertex.

A basic example of a schema is that of a set of labeled vertices with no edges or higher simplices connecting them.  This is obtained as a coproduct of $0$-simplices (see Remark \ref{rem:symmetric}), and it is called a {\em discrete schema}.

\end{example}

\subsection{Sheaves on a schema}

\begin{definition}

Let $X\in\Sch^\pi$ denote a schema.  A {\em subschema of $X$} consists of a schema $X'\in\Sch^\pi$ such that for every $\sigma\in\mcS^\pi$ we have $X'_\sigma\ss X_\sigma$.  The subschemas of $X$ form a category $\Sub(X)$, in which there is a morphism $X''\to X'$ in $\Sub(X)$ if and only if $X''$ is a subschema of $X'$.

A {\em sheaf on $X$} is a functor $\mcK\taking\Sub(X)\op\to\Sets$ such that, for every diagram $D\taking I\to\Sub(X)$ which has a colimit in $\Sub(X)$, the natural map $$\mcK(\colim(D))\too\lim(\mcK(D))$$ is an isomorphism.  That is $\mcK$ must send colimits of subschema to corresponding limits of sets.

A {\em morphism of sheaves on $X$} is a natural transformation of functors.  Let $\Shv(X)$ denote the category of sheaves on $X$.

\end{definition}

\begin{remark}\label{rem:sheaves}

Category theory experts will recognize $\Shv(X)$ as the category of sheaves on a certain site.  It is well known that $\Shv(X)$ is therefore closed under small limits and colimits.  Moreover, there is an adjunction $$\Adjoint{Sh}{\Pre(X)}{\Shv(X)}{}$$ for which the right adjoint is the forgetful functor and the left adjoint is called {\em sheafification}.  Roughly, one sheafifies a presheaf on a schema by replacing its value on each union of simplices by the fiber product of its values on those simplices.  See \cite{} for details.

\end{remark}

\begin{example}\label{ex:sheaves}

For any schema $X$, there is an object $\emptyset\in\Sub(X)$, which is the colimit of the empty diagram on $\Sub(X)$.  Hence if $\mcK$ is to be a sheaf on $X$, one must have $\mcK(\emptyset)\iso\{*\}$.

If $X$ is a discrete schema (see Example \ref{ex:gluing}), then $X$ is the coproduct its $0$-simplices.  Thus, if $\mcK$ is to be a sheaf on $X$, we must have $$\mcK(X)=\prod_{x\in X_0}\mcK(x).$$

\end{example}

\begin{example}\label{ex:sheaf on edge}

Suppose that $X\in\Sch^\pi$ is the schema $\Delta^{\{`\Str',`\ZZ'\}}$, which looks like this: $$\xymatrix@1{~^{`\Str'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^{`\ZZ'}.}$$  The category $\Sub(X)$ is a partially ordered set with five objects: $\emptyset$, $\bullet^{`\Str'}$,$\bullet^{`\ZZ'}$, $\{\bullet^{`\Str'},\bullet^{`\ZZ'}\}$, and $X$ itself; $\Sub(X)$ has inclusions as morphisms.  

A sheaf $\mcK\in\Shv(X)$ assigns a set to each of these five objects, and functions to each inclusion.  However, it must assign to $\emptyset$ the terminal set, $\mcK(\emptyset)=\singleton$, and it must assign to $\{\bullet^{`\Str'},\bullet^{`\ZZ'}\}$ the product $\mcK(\bullet^{`\Str'})\cross\mcK(\bullet^{`\ZZ'})$.  Thus, to specify a sheaf, we need only specify three values, and one morphism, namely $\mcK(X)\to\mcK(\{\bullet^{`\Str'},\bullet^{`\ZZ'}\})$.  

For example we may choose on objects the assignments $\mcK(X)=\{4,cc,10\}$, $\mcK(\bullet^{`\Str'})=\{1,2\}$, and $\mcK(\bullet^{`\ZZ'})=\{x,y,z\}$; this implies $\mcK(\{\bullet^{`\Str'},\bullet^{`\ZZ'}\})$ is isomorphic to $\{1x,1y,1z,2x,2y,2z\}$.  Any function from $\{4,cc,10\}$ to this six element set, say $4\mapsto 1x, cc\mapsto 1z, 10\mapsto 1z$, defines the restriction maps in our sheaf $\mcK$.  These restriction maps can be thought of as ``foreign keys."

\comment{A diagram depicting $\Sub(X)$.%%

$$\xymatrix@=10pt{&~^{`\Str'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[rr]&\ar[dd]&\hspace{-.2cm}\bullet^{`\ZZ'}\\\\&&\{\bullet^{`\Str'},\bullet^{`\ZZ'}\}\ar[dll]\ar[drr]\\\bullet^{`\Str'}\ar[drr]&&&&\bullet^{`\ZZ}\ar[dll]\\&&\emptyset}\mapsto$$

}%%


\end{example}

\begin{definition}

Given a schema $X\in\Sch^\pi$, we have been working with the category $\Sub(X)$ of subschemas of $X$.  There is a related category, called {\em the category of nonempty non-degenerate simple schema over $X$} and denoted $\ND(X)$, whose objects are \ul{m}onomorphisms $\Delta^\sigma\inj X$ in $\Sch^\pi$, where $\sigma\taking C\to\DT$ is a schema with $C\neq\emptyset$ (see Example \ref{ex:simplices}), and whose morphisms are commutative triangles.  

Every simplex in a schema has a unique underlying non-degenerate simplex (of which it is the degeneracy), so one can define a functor $\ND\taking\Sch^\pi\to\Cat$.

\end{definition}

Since every injection $\Delta^\sigma\inj X$ is in particular a subschema, there is an obvious functor $$\ND(X)\to\Sub(X).$$  This induces an adjunction $\Adjoint{}{\Pre(\ND(X))}{\Pre(\Sub(X)).}{}$  No unions exist in $\ND(X)$, so this adjunction becomes $$\Adjoint{L}{\Pre(\ND(X))}{\Shv(\Sub(X)),}{R}$$ where $\Pre(\ND(X))$ is the category of presheaves $\ND(X)\op\to\Sets$.  See \cite[C.1.4.3]{Joh}.

Notice that a map $f\taking X\to Y$ of schema induces a functor from simple schema over $X$ to simple schema over $Y$.

\begin{proposition}\label{prop:non-deg}

Let $X\in\Sch^\pi$ be a schema, and let $\ND(X)$ denote the category of non-degenerate nonempty simple schema over $X$.  The adjunction $$\Adjoint{L}{\Pre(\ND(X))}{\Shv(\Sub(X)),}{R}$$ is an equivalence of categories.

\end{proposition}

\begin{proof}

It is an easy exercise to show that $L\circ R$ is equal to the identity on $\Pre(\ND(X))$ and $R\circ L$ is canonically isomorphic to the identity on $\Shv(\Sub(X))$.  

\end{proof}

\begin{definition}\label{def:f^*}

Let $\pi\taking U\to\DT$ denote a type designation and let $f\taking X\to Y$ denote a morphism of schema on $\pi$.  There is an adjunction $$\Adjoint{f^*}{\Shv(\Sub(Y))}{\Shv(\Sub(X))}{f_*}$$ defined as follows for sheaves $\mcK_X\in\Shv(\Sub(X))$ and $\mcK_Y\in\Shv(\Sub(Y))$.  For any $U\in\Sub(X)$ we take $$f^*\mcK_Y(U):=\mcK_Y(f(U)),$$ where $f(U)\in\Sub(Y)$ is the image of $U$ in $Y$.  For any $V\in\Sub(Y)$ we take $$f_*\mcK_X(V):=\mcK_X(f^\m1(V)),$$ where $f^\m1(V)$ is the preimage of $V$ in $X$.

\end{definition}

\subsection{Simplicial databases}

We think of a schema as a way of organizing the data in a database.  Before we say what a database is, let us give one more example of a schema.  In some sense it will be the fundamental example of a schema; however, it should not really be thought of as a way to organize the data, but as the data itself.

\begin{example}\label{ex:universal record}

Let $\pi\taking U\to\DT$ denote a type designation, and let $\mcS=\mcS^\pi$ denote the category of simple schema on $\pi$.  Let $\Gamma^\pi\taking\mcS\op\to\Sets$ denote the functor which assigns to a schema $\sigma\taking C\to\DT$ the set $\Gamma^\pi(\sigma)$ of records on $\sigma$ (see Definition \ref{def:records}).

By Lemma \ref{induced morphisms}, a map $\sigma\to\sigma'$ induces a function $\Gamma^\pi(\sigma')\to\Gamma^\pi(\sigma)$, so $\Gamma^\pi$ is indeed a contravariant functor.  By definition we can consider $\Gamma^\pi$ as a schema on $\pi$ and write $\Gamma^\pi\in\Sch^\pi$.

We call $\Gamma^\pi$ {\em the universal record on $\pi$,} for reasons which will be clear soon.  If the type designation $\pi\taking U\to\DT$ is obvious from context, we may denote $\Gamma^\pi$ simply by $\Gamma$.  

\end{example}


\begin{definition}\label{def:universal sheaf}

Let $\pi\taking U\to\DT$ denote a type designation, let $\Gamma^\pi$ denote the universal record on $\pi$, and let $X\in\Sch^\pi$ denote a schema on $\pi$.  The {\em universal sheaf on $X$ of type $\pi$} is the sheaf $\mcU^\pi$ whose value on a subschema $X'\ss X$ is given by $$\mcU^\pi(X')=\Hom_{\Sch^\pi}(X',\Gamma^\pi).$$  Each element of $\mcU^\pi(X')$ is called a {\em record on $X'$ of type $\pi$}.  If $\pi$ is clear from context, we may write $\mcU$ to denote $\mcU^\pi$.

Now let $X,Y\in\Sch^\pi$ be schema and let $\mcU_X$ and $\mcU_Y$ denote the universal sheaf of type $\pi$ on $X$ and $Y$ respectively.  A map of schema $f\taking X\to Y$ induces a morphism $\mcU_f\taking f^*\mcU_Y\to\mcU_X$ as follows.  If $\Delta^\sigma\inj X$ is a non-degenerate simple schema over, we have a morphism of simple schema $f\taking \Delta^\sigma\to f(\Delta^\sigma)$ which induces a map $\Gamma^\pi(f(\Delta^\sigma))\to\Gamma^\pi(\Delta^\sigma)$.  Here we are implicitly using the result of Proposition \ref{prop:non-deg}.

\end{definition}

\begin{definition}\label{def:database objects}

Let $\pi\taking U\to\DT$ denote a type designation.  A {\em simplicial database (\tn{or simply} database) of type $\pi$} is a triple $(X,\mcK,\tau)$ where $X\in\Sch^\pi$ is a schema of type $\pi$, $\mcK\in\Shv(X)$ is a sheaf of sets on $\Sub(X)$, and $\tau\taking\mcK\to\mcU^\pi$ is a morphism of sheaves on $X$ (see Definition \ref{def:universal sheaf}).  We refer to $X$ as {\em the schema}, $\mcK$ as {\em the keys}, and $\tau$ as {\em the data} of the database $(X,\mcK,\tau)$.

\end{definition}

\begin{remark}\label{rem:internal keys}

Given a set of ways to measure objects, it often happens that we have several objects with the same measurements.  For example, we may have three green apples, or two 1999 Toyota Corolla's.  In relational databases, if two objects have the same attributes, then they are the same.  To keep them distinct, one introduces a unique identifier, which becomes part of the data.  This causes problems with database integration, because the arbitrarily-chosen identifiers in one database will generally not match with those in another.

In our definition, the keys for the data are kept separate, as the sheaf of sets $\mcK$.  Different names for the keys in no way interfere with database integration.  The keys are internal and stand for the objects themselves, which are measured by their attributes but not confused with them.

Finally, the restriction maps $\mcK(X)\to\mcK(X')$ for subschemas $X'\ss X$ send key sets to key sets.  In this way, $\mcK$ gives a systematic way to encode a system of foreign keys.

\end{remark}

\begin{example}\label{ex:database}

In Example \ref{ex:sheaf on edge}, we wrote down a sheaf $\mcK\in\Shv(X)$ on the schema $$X=\xymatrix@1{~^{`\Str'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^{`\ZZ'},}$$ and we will continue to use it in this example.  To specify a database on $X$ of type $\pi$, we must give a morphism $\tau\taking\mcK\to\mcU^\pi$ of sheaves on $X$.

We defined the universal sheaf $\mcU$ of type $\pi$ on $X$ in Definition \ref{def:universal sheaf}.  We have \begin{align*}\mcU^\pi(X)=\mcU^\pi(\{\bullet^{`\Str'},\bullet^{`\ZZ'}\})&=\Str\cross\ZZ\\\mcU^\pi(\bullet^{`\Str'})&=\Str\\\mcU^\pi(\bullet^{`\ZZ'})&=\ZZ\\\mcU^\pi(\emptyset)&=\singleton.\end{align*} 

To define a map $\tau\taking\mcK\to\mcU^\pi$, we must give maps $$\begin{array}{lll}\tau(\bullet^{`\Str'})\taking\mcK(\bullet^{`\Str'})\to\mcU^\pi(\bullet^{`\Str'}), &&\tau(\bullet^{`\ZZ'})\taking\mcK(\bullet^{`\ZZ'})\to\mcU^\pi(\bullet^{`\ZZ'})\end{array}$$ and $$\tau(X)\taking\mcK(X)\to\mcU^\pi(X)$$ that compose correctly with the restriction maps.  We arbitrarily assign $$\begin{array}{lllllll}\tau(1)&=&\tn{Barack}&&\tau(x)&=&48\\\tau(2)&=&\tn{Michelle}&&\tau(y)&=&62\\&&&&\tau(z)&=&45.\end{array}$$  Now $\mcK(X)=\{4,cc,10\}$, and the restriction map sends $4\mapsto 1x$, $cc\mapsto 1z$, and $10\mapsto 1z$.  This forces $\tau(4)=\tn{(Barack, 48)}$ and $\tau(cc)=\tau(10)=\tn{(Michelle,45)}$.  The other values and restriction maps for $\mcK$ are also forced.

\end{example}

\begin{example}

In Example \ref{ex:database}, we followed the definitions very closely, perhaps to the detriment of the big ideas.  In this example, we write down how the sheaf ``looks" as tables.  

Let us first change the schema $X$ very slightly, by using the schema $\sigma\taking\{\tn{First, Age}\}\to\DT$, where $\sigma(\tn{First})=\tn{`Str'}$ and $\sigma(\tn{Age})=`\ZZ$', and now taking $X=\Delta^\sigma$.  The only difference is that we have labeled our columns by attributes rather than their values.  We write $\tau(X)\taking\mcK(X)\to\mcU^\pi(X)$ as the table $$\begin{tabular}{|l||l|l|}\hline $\tau(X)$&First&Age\\\hline\hline4&Barack&48\\\hline cc&Michelle&45\\\hline 10&Michelle&45\\\hline\end{tabular}$$  We write $\tau(\bullet^\tn{First})$ and $\tau(\bullet^\tn{Age})$ as tables $$\begin{tabular}{|l||l|}\hline$\tau(\bullet^\tn{First})$&First\\\hline\hline 1&Barack\\\hline2&Michelle\\\hline\end{tabular}\hspace{.5in}\begin{tabular}{|l||l|}\hline$\tau(\bullet^\tn{Age})$&Age\\\hline\hline x&48\\\hline y&62\\\hline z&45\\\hline\end{tabular}$$

We could consider the restriction maps $\mcK(X)\to\mcK(\bullet^\tn{First})$ and $\mcK(X)\to\mcK(\bullet^\tn{Age})$ as foreign keys attached to the $\tau(X)$ table.  However the way things are set up, this foreign key information is kept in the sheaf $\mcK$ and not in the morphism $\tau$.  See Example \ref{ex:sheaf on edge}.

\end{example}

\begin{definition}\label{def:database morphisms}

Let $\pi\taking U\to\DT$ denote a type designation, let $\mcX=(X,\mcK_X,\tau_X)$ and $\mcY=(Y,\mcK_Y,\tau_Y)$ denote databases of type $\pi$, and let $\mcU_X$ and $\mcU_Y$ denote the universal sheaf on $X$ and $Y$ (see Definition \ref{def:universal sheaf}).  A {\em morphism of databases}, denoted $$(f,f^\sharp)\taking\mcX\to\mcY,$$ consists of a map $f\taking X\to Y$ of schema (see Definition \ref{def:schema}) and a morphism of sheaves $f^\sharp\taking f^*\mcK_Y\to\mcK_X$ on $X$ such that the diagram of sheaves \begin{eqnarray}\label{dia:integrity}\xymatrix{f^*\mcK_Y\ar[r]^{\tau_Y}\ar[d]_{f^\sharp}&f^*\mcU_Y\ar[d]^{\mcU_f}\\\mcK_X\ar[r]_{\tau_X}&\mcU_X}\end{eqnarray} commutes.

The {\em category of simplicial databases on $\pi$}, whose objects are simplicial databases as defined in Definition \ref{def:database objects} and whose morphisms have just been defined is denoted $\Data^\pi$, or simply $\Data$ if $\pi$ is understood.  Fixing a schema $X$, the {\em category of databases on $X$}, denoted $\Data_X$, is the category whose objects are databases with schema $X$ and whose morphisms are identity on $X$.  

A {\em morphism without integrity} is a pair $(f,f^\sharp)\taking\mcX\to\mcY$ {\em without} the requirement that diagram (\ref{dia:integrity}) commute.

\end{definition}

\begin{remark}\label{rem:data integrity}

A database is roughly a bunch of tables glued together by foreign key mappings.  A morphism of databases is a way to assign to each table in one database, a table in another database, and a morphism between them.  A morphism of tables is a ``data-preserving map" (see Definition \ref{def:morphism of tables}, Example \ref{ex:morphism of tables}, and Remark \ref{rem:table integrity}).  Thus, a morphism of databases should be thought of as a coherent system of data-preserving maps.

\end{remark}

\begin{remark}\label{rem:data_X}

Let $X$ be a schema and let $\mcU_X$ denote the universal database on $X$.  One can identify $\Data_X$ with the category $\Shv(X)_{/\mcU_X}$ of sheaves over $\mcU_X$.  Explicitly, this is the category whose objects are arrows $\mcK\to\mcU_X$ and whose morphisms are commutative triangles.

\end{remark}

\subsection{Relational simplicial databases}\label{Subsec:relational}

We finish this section by giving a version of relational databases in our context and then explaining explicitly how one converts a relational simplicial database into a relational database.

\begin{definition}

Let $\pi$ denote a type designation.  A simplicial database $\mcX=(X,\mcK,\tau)$ on $\pi$ is {\em relational} if $\tau\taking\mcK\to\mcU_X$ is a monomorphism of sheaves.  The {\em category of relational simplicial databases}, denoted $\mcRel^\pi$ is the full subcategory of $\Data^\pi$ spanned by the relational databases.

\end{definition}

Note the similarity of this definition with Definition \ref{def:relational table}: the schema $X$ is a gluing together of simple schema $\sigma$, the sheaf $\mcU_X$ evaluated on a simplex $\Delta^\sigma\ss X$ is $\Gamma(\sigma)$, and a monomorphism of sheaves is a morphism which restricts to an injective function on each simplex.

Every function $f\taking A\to B$ between sets has an image $\im(f)\ss B$ and an injection $f^m\taking\im(f)\to B$; similarly, given a schema $X$, every morphism $f\taking \mcA\to\mcB$ of sheaves of sets on $X$ has an image sheaf denoted $\im(f)\ss\mcB$ and a monomorphism of sheaves $f^m\taking\im(f)\to\mcB$.  If $\mcX=(X,\mcK,\tau)$ is a database, we can take the image sheaf $\im(\tau)$ of $\tau\taking\mcK\to\mcU_X$ and the database $(X,\im(\tau),\tau^m)$ is a relational database.

\begin{lemma}\label{lemma:adj rel data}

Let $\pi$ denote a type designation.  There is an adjunction $$\Adjoint{}{\Data^\pi}{\mcRel^\pi}{}$$ in which the left adjoint is given by $(X,\mcK,\tau)\mapsto(X,\im(\tau),\tau^m)$ and the right adjoint is the forgetful functor which realizes a relational database as a database.

\end{lemma}

\begin{proof}

This is a simple exercise coming from the fact that the image functor, which sends the category of sets and functions to the category of sets and injections, is a left adjoint to the forgetful functor.

\end{proof}

Since the forgetful functor $\mcRel\to\Data$ is fully faithful, the counit of the adjunction in Lemma \ref{lemma:adj rel data} is the identity.  Another way to say this is that one does not lose information when considering a relational database as a simplicial database, but one often does lose information when converting a simplicial database to a relational database.  Strictly ``more information" can be contained in a simplicial database than in a simplicial relational database.

\subsection{Tables vs. simplicial databases}

In this last section we present the functor $F\taking\Tables\to\Data$ which realizes a table as a simplicial database.  Because of the way we have chosen to think of the category of simplicial databases, the functor $F$ is {\em contravariant}: a map of tables induces a map of simplicial databases in the opposite direction.  We will also present ...

\begin{construction}\label{con:table as database}

Let $\pi\taking U\to\DT$ denote a type designation and $(K,C,\sigma,\tau)$ a table on $\pi$ (see Definition \ref{def:tables}).  Let $X=\Delta^\sigma\in\Sch^\pi$ be the associated schema, let $\mcU_X$ denote the universal database on $X$, and let $\mcK_X$ denote the constant sheaf on $\Sub(X)$ which takes each subschema to the set $K$.  Define $\tau_X\taking\mcK_X\to\mcU_X$ in the unique way such that $\tau_X(X)\taking\mcK_X(X)\to\mcU_X(X)$ is precisely $\tau\taking K\to\Gamma(\sigma)$. 

Given a map of tables $\varphi\taking(K_1,C_1,\sigma_1,\tau_1)\to(K_2,C_2,\sigma_2,\tau_2)$, there is a canonical map of simplicial databases $(X_2,\mcK_2,\tau_2)\to(X_1,\mcK_1,\tau_1)$.  Recall from Definition \ref{def:morphism of tables} that $\varphi=(g,f)$ where $g\taking K_1\to K_2$ is a function and $f\taking\sigma_2\to\sigma_1$ is a morphism of simple schema such that Diagram \ref{dia:morphism of tables}, rewritten for the readers convenience here: $$\xymatrix{K_1\ar[r]^{\tau_1}\ar[d]_g&\Gamma(\sigma_1)\ar[d]^{f^*}\\K_2\ar[r]_{\tau_2}&\Gamma(\sigma_2)}$$ commutes.

The morphism $f\taking\sigma_2\to\sigma_1$ of simple schema induces a morphism $\Delta^{\sigma_2}\to\Delta^{\sigma_1}$ of schema, i.e. a map $f\taking X_2\to X_1$.  The sheaf $f^*\mcK_1$ on $X_2$ is the constant sheaf with value $K_1$, so $g$ gives a map $f^*\mcK_1\to\mcK_2$.  We will skip some details, but one can easily show that the commutativity of the Diagram \ref{dia:integrity} is equivalent to the commutativity of Diagram \ref{dia:morphism of tables}, completing the construction.

\end{construction}

We can also extract a single table from a simplicial database, by looking at its global sections.  This requires a functor called $f_+$ defined in Section \ref{subsec:changing the schema} in the following section.  Since we only include this construction for the reader's edification, and never use the result, we do so here in order to keep like topics together.

\begin{construction}\label{con:database as table}

Let $\mcX=(X,\mcK,\tau)$ denote a simplicial database.  Recall from Remark \ref{rem:symmetric} that there is an induced classification map $c\taking X_0\to\DT$.  Assuming that $X$ has finitely many vertices, we can construct a table whose simple schema is $c$.  

To do so, we need only note that there is a unique map of schema $f\taking X\to\Delta^c$.  Given any simplex in $X$, its set of vertices classifies a unique simplex in $\Delta^c$; this defines $f$.  We can now construct the table $$(\mcK(X),X_0,c\taking X_0\to\DT,f_+\tau_X(X)).$$  Its columns are given by the vertices $X_0$ of $X$; its rows are difficult to describe in general, but in specific cases are quite sensible.

\end{construction}

\begin{remark}\label{rem:adj tables data}

It is not hard to show that the two above constructions establish an adjunction $$\Adjoint{}{\Tables}{\Data\op}{}$$  Given a database $\mcX$, the table obtained by the right adjoint will be called the {\em global table on $\mcX$.}

\end{remark}

\section{Constructions and formal properties of Simplicial Databases}\label{sec:constructions for databases}


The point of all of the above formalism is to find a language in which to describe databases such that the typical operations performed when working with databases are sensible in the language.  In other words, queries of databases should make sense as categorical constructions, as they did in Section \ref{sec:constructions for tables}.  

\subsection{Changing the schema}\label{subsec:changing the schema}

Let us begin with some ways that one can import data from one schema into another.  In Definition \ref{def:f^*} we discuss the adjunction $$\Adjoint{f^*}{\Shv(\Sub(Y))}{\Shv(\Sub(X))}{f_*}$$ induced by a map of schema $f\taking X\to Y$.  Given a database $\mcY=(Y,\mcK_Y,\tau_Y)$ on $Y$ there is an induced database $(X,f^*\mcK_Y,\mcU_f\circ (f^*\tau_Y))$, denote $f^*\mcY$; see Definition \ref{def:universal sheaf} and refer to the diagram $$\xymatrix{f^*\mcK_Y\ar[r]^{f^*\tau_Y}\ar[dr]&f^*\mcU_Y\ar[d]^{\mcU_f}\\&\mcU_X.}$$  

A slightly more complicated construction creates a database on $Y$ from a database $\mcX=(X,\mcK_X,\tau_X)$ on $X$ and a map of schema $f\taking X\to Y$.  By the adjunction, we have the diagram \begin{eqnarray}\label{dia:problem}\xymatrix{&\mcU_Y\ar[d]\\f_*\mcK_X\ar[r]_{f_*\tau_X}&f_*\mcU_X,}\end{eqnarray} but since there is no canonical map $f_*\mcK_X\to\mcU_Y$, we have not yet constructed a database on $Y$. 

To do so, let $f_+(\mcK_X)$ denote the limit of Diagram (\ref{dia:problem}).  This sheaf comes with a canonical map to $\mcU_Y$, which we denote $f_+\tau_X\taking f_+\mcK_X\to\mcU_Y$.  The triple $(Y,f_+\mcK_X,f_+\tau_X)$ is a database on $Y$, which we denote $f_+\mcX$.  

\begin{proposition}

Let $\pi$ denote a type designation, and let $f\taking X\to Y$ be a morphism of schema of type $\pi$.  The functors $f^*$ and $f_+$ define an adjunction $$\Adjoint{f^*}{\Data_Y}{\Data_X.}{f_+}$$

\end{proposition}

\begin{proof}

Let $\mcX=(X,\mcK_X,\tau_X)$ and $\mcY=(Y,\mcK_Y,\tau_Y)$ be databases.  Giving a morphism $f^*\mcY\to\mcX$ of databases over $X$ amounts to a giving a map $\alpha$ of sheaves making the diagram $$\xymatrix{f^*\mcK_Y\ar[r]^{f^*\tau_Y}\ar@{-->}[d]_\alpha&f^*\mcU_Y\ar[d]^{\mcU_f}\\\mcK_X\ar[r]_{\tau_X}&\mcU_X}$$ commute.  This diagram is equivalent to the diagram $$\xymatrix{\mcK_Y\ar[r]^{\tau_Y}\ar@{-->}[d]_\alpha&\mcU_Y\ar[d]^{\mcU_f}\\f_*\mcK_X\ar[r]_{f_*\tau_X}&f_*\mcU_X,}$$ by Definition \ref{def:f^*}.  Supplying a morphism $\alpha$ is equivalent to supplying a morphism $\mcK_Y\to f_+\mcK_X$ over $\mcU_Y$, because $f_+\mcK_X$ is the limit of Diagram \ref{dia:problem}.  The proof now follows from Remark \ref{rem:data_X}.

\end{proof}

\begin{example}

Let $X$ and $Y$ be the schema $$X:=\xymatrix@1{~^{`\Str'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^{`\Str'},} \hspace{.5in}Y:=\xymatrix@1{~^{`\Str'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^{`\ZZ'},}$$ and let $f\taking X\to Y$ be the unique morphism of schema between them.  

By Remark \ref{rem:data_X}, a database on $Y$ is given by a morphism of sheaves $\tau_Y\taking\mcK_Y\to\mcU_Y$, for some sheaf of sets $\mcK_Y$.  We roughly think of it as a table of strings and integers, with some values not filled in.  (In fact, $\tau_Y$ has more information because, for example, two keys in $\mcK(Y)$ can be sent to the same key in $\mcK(\bullet^{`\Str'})$ if their strings match).

The database $f^*\tau_Y\taking f^*\mcK_Y\to\mcU_X$ is degenerate in the sense that every row has the same string repeated in two columns.  In some sense, this is to be expected.

Now suppose that $\tau_X\taking\mcK_X\to\mcU_X$ is a database on $X$.  We roughly think of it as a table whose rows are pairs of strings.  The push-forward $f_+\tau_X$ consists of three tables: one has two columns (strings and integers) and the other two just have one column.  The one column table of integers $f_+\tau_X(\bullet^{`\ZZ'})$ is empty.  The one column table of strings $f_+\tau_X(\bullet^{`\Str'})$ consists of those strings $S$ for which there is a row in $\tau_X(X)$ consisting of a repeated string $(S,S)$.  Finally, the two column table $f_+\tau_X(Y)$ consists of an element $(S,n)$ for every row $S$ in the one-column table of strings and every integer $n\in\ZZ$. 

One sees that by this example that if $f\taking X\to Y$ is not surjective, then the pushforward functor $f_+$ results in huge tables.  It is not meant to be implemented as a hash table but as a theoretical construct.

\end{example}

Given a map of schemas $f\taking X\to Y$, there is one more important way to send a database on $X$ to a database on $Y$, but only if $f$ is a monomorphism of schema.  We think of it as ``extension by $\emptyset$," meaning that for every simplex in $Y$ that is not in $X$, we simply put an empty table.  We denote by $f_!\taking\Data_X\to\Data_Y$ the functor which accomplishes this task. 

To define $f_!$ rigorously, we first recall that $f^*\taking\Shv(Y)\to\Shv(X)$ not only has a right adjoint ($f_*$), but a left adjoint as well, which we also denote $f_!\taking\Shv(X)\to\Shv(Y)$.  If $f$ is a monomorphism, then every subschema $X'\ss X$ is sent to a subschema $f(X')\ss Y$.  Every subschema $Y'\ss Y$ is either of the form $Y'=f(X')$ or not.  If so then we have $f_!\mcU_X(Y')=\mcU_X(X')=\mcU_Y(Y')$.  If not then we have $f_!\mcU_X(Y')=\emptyset$.  There is a canonical map $a_f\taking f_!\mcU_X\to\mcU_Y$ which is the identity map on $Y'=f(X')$ and which is $\emptyset\to\mcU_Y(Y')$ when $Y'\not\in\im(f)$.

Now that we have a canonical map $a_f\taking f_!\mcU_X\to\mcU_Y$ in the case that $f\taking X\to Y$ is an inclusion, we can define $f_!\taking\Data_X\to\Data_Y$ to be given by $$f_!(X,\mcK_X,\tau_X):=(Y,f_!\mcK_X,a_f\circ\tau_X).$$  The functor $f_!$ is left adjoint to the functor $f^*\taking\Data_Y\to\Data_X$ (but $f_!$ is defined only when $f\taking X\to Y$ is an injection.)

\subsection{Duplication of records}\label{subsec:duplication}

Nulls are a touchy subject in the relational database community, because they do not conform with the mathematical logic that underlies the strict theoretical foundation of relational databases.  They are easy enough to deal with, however, by use of foreign keys.  That is, for each column $c\in C$ of a schema $\sigma\taking C\to\DT$ for which a tables may contain a null, one creates a new schema $\sigma'$ on columns $C'=C-\{c\}$.  By a simple use of foreign keys, one considers objects classified by $\sigma$ to be also classified by $\sigma'$.  This is a easy way to get around the problem of nulls.

The same technique is done (automatically) in simplicial databases.  Over a simplex $\Delta^\sigma$, one puts objects for which the value on each column is known.  If the value on some set of columns is unknown for a certain object, one simply holds it as a record on a subsimplex.  

Unlike relational databases, however, simplicial database allow for duplicate entries.  This is as simple as allowing functions $\tau\taking K\to\Gamma(\sigma)$ that are not injections.  The key set $K$ distinguishes between different objects, which takes the burden off of the data itself.  However, $K$ is not part of the data.  

The relational model tends to identify objects with a certain list of attributes.  No two objects are allowed to have the same attributes.  One can claim that in reality, no two objects have precisely the same attributes, and this is true.  However a schema does not consider every possible attribute but a small and pre-defined set of attributes.  It is quite possible that two objects will look the same to that schema. 

In the simplicial database model (or any model in which one allows non-injective tables $\tau$), the object is not confused with its list of attributes.  That is, different objects can ``look the same" to a given schema.  The schema represents ways to distinguish between objects, and the relational model demands perfection on this front: if two objects are different then they must be distinguishable by the chosen schema.  Our simplicial model does not demand perfection in this sense, but loses no mathematical rigor or power; it simply gains flexibility.  As shown in Lemma \ref{lemma:adj rel data}, every relational database can be considered as a simplicial database in a functorial way, but there are strictly more simplicial databases because they allow for duplicate entries.

\subsection{Limits and colimits of databases}

We will see shortly that limits and colimits taken in the category of simplicial databases have meaning in terms of the general theory of databases, such as unions and joins.  

\begin{theorem}\label{thm:colimits and limits}

Let $\pi\taking U\to\DT$ denote a type designation.  The category $\Data^\pi$ of databases of type $\pi$ is closed under taking small colimits and small limits.

\end{theorem}

\begin{proof}

Let $I$ denote a small category and let $\mcX\taking I\to\Data$ denote an $I$-shaped diagram in $\Data=\Data^\pi$; for $i\in I$.  There is a functor $\Data\to\Sch$ taking a database $(A,\mcK_A,\tau_A)$ to its underlying schema $A$, and composing this functor with $\mcX$ gives a functor which we denote $X\taking I\to\Sch$.  For an object $i\in I$, we denote the database $\mcX(i)$ by $\mcX_i$ and write $$\mcX_i=(X_i,\mcK_i,\tau_i).$$

To define the colimit (respectively limit) of the diagram $\mcX$, we must first specify its schema.  Since $\Sch=\Pre(\mcS)$, where $\mcS$ is the category of simple schema (see Definition \ref{def:category of schema}), it is closed under colimits and limits.  Let $C=\colim(X)$ (resp. $L=\lim(X)$) denote the colimit (resp. limit) of the diagram $X\taking I\to\Sch$.  Let $\mcU_C$ and $\mcU_L$ denote the universal databases on $C$ and $L$, respectively.

As a colimit, $C$ comes equipped with morphisms $c_i\taking X_i\to C$, for each $i\in I$, making the appropriate diagrams commute.  There is a push-forward sheaf $(c_i)_+\mcK_i$ on $C$, which comes equipped with a map $(c_i)_+\tau\taking (c_i)_+\mcK_i\to\mcU_C$.  If $f\taking i\to j$ is a morphism in $I$, then there is an induced morphism $$(c_j)_+\mcK_j\to (c_i)_+\mcK_i$$ of push-forward sheaves over $\mcU_C$ on $C$.  Let $c_+\taking I\op\to\Shv(C)_{/\mcU_C}$ denote the $I\op$-shaped diagram of these push-forward sheaves over $\mcU_C$.  Define $\tau_c\taking\mcK_C\to\mcU_C$ to be the limit of this diagram.  Then the database $$\mcC=(C,\mcK_C,\tau_C)$$ is our candidate for the colimit of the diagram $\mcX$.  It is a matter of tracing through the construction to show that $\mcC$ has the necessary universal property.

Defining the limit of $\mcX$ is similar.  As a limit of schema $L$ comes equipped with morphisms $\ell_i\taking L_i\to X_i$, for each $i\in I$, making the appropriate diagrams commute.  There is a pullback sheaf $\ell_i^*\mcK_i$ on $L$, which comes equipped with a map $\ell_i^*\tau\taking\ell_i^*\mcK_i\to\mcU_L$.  If $f\taking i\to j$ is a morphism in $I$, then there is an induced morphism $$\ell_j^*\mcK_j\to\ell_j^*\mcK_i$$ of pullback sheaves over $\mcU_L$ on $L$.  Let $\ell^*\taking I\op\to\Shv(L)_{/\mcU_L}$ denote the $I\op$-shaped diagram of pullback sheaves over $\mcU_L$.  Define $\tau_\ell\taking\mcK_L\to\mcU_L$ to be the colimit of this diagram.  Then the database $$\mcL=(L,\mcK_L,\tau_L)$$ is our candidate for the limit of the diagram $\mcX$.  Again, it is a matter of tracing through the construction to show that $\mcL$ has the necessary universal property.  

This completes the proof.

\end{proof}

\begin{remark}

The initial object in the category $\Data^\pi$ of databases on $\pi\taking U\to\DT$ is the empty database (with empty schema and thus no sheaf).  The final object $(X,\mcK,\tau)$ in $\Data^\pi$ has a single $n$-simplex for every map $\sigma\taking\{0,1,\ldots,n\})\to\DT$; the sheaf is $\mcK=\mcU_X$ and the map $\tau\taking\mcU_X\to\mcU_X$ is the identity.

If one knows the \Cech nerve construction, one can realize the final object in those terms, by applying the \Cech nerve functor to $\pi\taking U\to\DT$.  See \cite[3.1]{Spi} for details.

\end{remark}

\begin{corollary}\label{cor:colimits and limits}

Let $X\in\Sch$ be a schema and let $\Data_X$ denote the category of databases with schema $X$ and with morphisms which restrict to the identity on $X$.  Colimits and limits exist in $\Data_X$; in particular it has an initial object and a final object.

\end{corollary}

\begin{proof}

Given a non-empty diagram which restricts to the identity on a certain schema $X$, one sees by the construction of limits and colimits in the proof of Theorem \ref{thm:colimits and limits} that the colimit and the limit of that diagram will also have schema $X$.  

The colimit (respectively the limit) of the empty diagram in $\Data_X$, if it exists, is the initial (resp. final) object in $\Data_X$; we must show it does exist.  Keeping in mind the contravariance in the sheaf, one immediately sees that the initial object is $(X,\mcU_X,\id_{\mcU_X})$, and the final object is $(X,\emptyset,\emptyset\to\mcU_X)$, where $\emptyset$ here denotes the sheaf on $X$ whose value is constantly the empty set, and where $\emptyset\to\mcU_X$ is the unique morphism.


\end{proof}

\subsection{Projections}\label{subsec:projections}

This query is built into the theory of simplicial databases.  Given a database $(X,\mcK,\tau)$ and a subschema $X'\ss X$, we have the database $(X',\mcK|_{X'}\tau|_{X'})$ given by restricting the sheaf $\mcK$ and the map of sheaves $\tau\taking\mcK\to\mcU$ to the subschema $X'$.  One can view it as a table using construction \ref{con:database as table}.

\subsection{Unions and insertions}

Given two databases with the same schema, one can take their union.  This means that we keep the same columns and take the union of the rows.  An insertion is a special kind of union; namely it is a union of two databases on the same schema, where one of the databases consists only of a single row.

We have a few more options in simplicial databases than one does in relational databases; these differences are analogous to the difference between the UNION query and the UNION ALL query in SQL.  That is, since we allow duplicate entries, the user can decide when an object in one database is the same as an object with the same attributes stored in another database and when it is different.  

We can accomplish unions, insertions, and much more by taking limits of databases.  Let $\mcX=(X,\mcK,\tau)$ denote a simplicial database, and let $\mcX'=(X,\mcK',\tau')$ be a database with the same schema, $X$.  Both map to the terminal database on $X$, and the fiber product will be $(X,\mcK\amalg\mcK',\tau\amalg\tau')$ as desired.  (See the proof of Theorem \ref{thm:colimits and limits} for details on the limit construction.)

The above construction gives a disjoint union: duplicate entries will remain distinct.  There are two ways of having that not be the case.  The first is to eliminate the duplicates by converting the database to a relational database; see Lemma \ref{lemma:adj rel data}.  The other way can occur if the user has more information about which people in the first database correspond to people in the second database.  This can be accomplished by having a third database $\mcX''=(X,\mcK'',\tau'')$ and maps from the first two to it.  The limit of this diagram, $(X,\mcK\amalg_{\mcK''}\mcK',\tau\amalg_{\tau''}\tau')$, will be the union of the records in $\mcX$ with those in $\mcX'$, and will identify two records if they agree in $\mcX''$.

As mentioned above, inserting a row is a special case of taking the union of databases.

We can take much more general limits than those mentioned above, all of which were constant in the schema.  These constructions appear to be new; we will discuss their applications in Section \ref{sec:applications} 

\subsection{Join}\label{subsec:join}

Two databases can be joined together by specifying a common sub-database of each and ``gluing together" along that sub-database.  If no common sub-database is mentioned we take the initial database which has empty schema and join along that; the result is called the natural join.  The point is, joining can be accomplished by taking colimits of databases.

Recall from Theorem \ref{thm:colimits and limits} that the colimit of the diagram of databases $$(X_1,\mcK_1,\tau_1)\from(X,\mcK,\tau)\to(X_2,\mcK_2,\tau_2)$$ has schema $X'=X_1\amalg_XX_2$.  There are structure maps from each of $X_1$, $X$, and $X_2$ to $X'$, making necessary triangles commute.  We can thus push-forward $\mcK_1$, $\mcK$, and $\mcK_2$ to $X'$ and get a diagram of push-forward sheaves there, all naturally mapping to $\mcU_{X'}$.  For typographical reasons, we leave out the fact that these are push-forwards and write the diagram $\mcK_1\to\mcK\from\mcK_2$ over $\mcU_{X'}$.  We are ready to write the colimit database as $$(X_1\amalg_XX_2,\mcK_1\cross_\mcK\mcK_2,\tau')$$ where $\tau'\taking\mcK_1\cross_\mcK\mcK_2\to\mcU_{X'}$ is the obvious map.

\begin{example}

Suppose we have the two schemas pictured here: $$X_1:=\xymatrix@1{~^\tn{`First'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^\tn{`Last'}}, \hspace{.5in}X_2:=\xymatrix@1{~^\tn{`L.Name'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^\tn{`Age'},}$$ and wish to join them together by equating `Last' with `L.Name' (both of which have the same data type, namely $\Str$).  To do so, we use the schema $X=\bullet^{`\Str'}$, which maps to each of $X_1$ and $X_2$ in an obvious way.  

Now given any databases $\mcX_1=(X_1,\mcK_1,\tau_1)$ and $\mcX_2=(X_2,\mcK_2,\tau_2)$ on $X_1$ and $X_2$, we can join them by taking the colimit of the solid arrow diagram $$\xymatrix{\mcX\ar[r]\ar[d]&\mcX_2\ar@{-->}[d]\\\mcX_1\ar@{-->}[r]&\mcX_1\amalg_\mcX\mcX_2,}$$ where $\mcX=(X,\mcU_X,\id_{\mcU_X})$ is the initial database on $X$.  The schema of the resulting database has three 0-simplices and two non-degenerate 1-simplices (and no non-degenerate higher simplices).  Its global table (see Remark \ref{rem:adj tables data}) has as records those triples of the form (First,Last,Age), for which there is a (First,Last) pair in $\mcX_1$ and a (Last,Age) pair in $\mcX_2$ with matching values of Last.  This is indeed their join.

\end{example}

\begin{remark}

The ``join" we are working with here could be thought of as a combination of equi-join and outer join.  Because databases are sheaves on a schema, they do not have just one value but a system of values, and the idea of nulls is built into the theory (see Section \ref{subsec:nulls and duplicates}).  

More precisely, if $\mcX_1\from\mcX\to\mcX_2$ is a diagram of databases, the colimit $\mcX'$ represents the join of $\mcX_1$ and $\mcX_2$ along a shared set of columns ($\mcX$).  Its schema is roughly the union of the schemas of $\mcX_1$ and $\mcX_2$.  Its global table will be the join of the global tables for $\mcX_1$ and $\mcX_2$.  The point of this remark, however, is that the $\mcX'$ does not contain only global information, but local information as well.  Much of the data of $\mcX_1$ is preserved upon passage to $\mcX'$, and since it is not global data, it will appear with nulls when viewed as global data.

\end{remark}

When joining databases together, one first chooses a set $C$ of columns to equate.  When two distinct objects have the same $C$-attributes, then the join is ``lossy" in the sense that there will be false information in the join.  To remedy this, one must be careful to distinguish between objects, even when considered only in terms of $C$.  The following example will make this more clear.

\begin{example}

Suppose one wants to join the following two tables: $$\xymatrix@=12pt{\hbox{\begin{tabular}{|l||l|l|}$\tau_1$&Title&LastName\\\hline\hline 1&Dr.&Marx\\\hline 2&Mr.&Marx\\\hline\end{tabular}}&&\hbox{\begin{tabular}{|l||l|l|}$\tau_2$&FirstName&LastName\\\hline\hline A&Karl&Marx\\\hline B&Groucho&Marx\\\hline\end{tabular}}}$$ The outcome will be the following table: $$\begin{tabular}{|l|l|l|}Title&FirstName&LastName\\\hline\hline Dr.&Karl&Marx\\\hline Dr.&Groucho&Marx\\\hline Mr.&Karl&Marx\\\hline Mr.&Groucho&Marx\\\hline\end{tabular}$$  This table has four entries, two of which are ``accurate," in that they describe real objects, and two of which are not.  This occurs because the relational database cannot distinguish between the two instances of the last name Marx.  

Achieving a lossless join is easy, when databases are allowed to have duplicate entries with the same attributes.  Consider the table $$\begin{tabular}{|l||l|}$\tau$&LastName\\\hline\hline x&Marx\\\hline y&Marx\\\hline\end{tabular}$$ which accepts maps from both $\tau_1$ and $\tau_2$ by sending $1$ and $A$ to $x$ and sending $2$ and $B$ to $y$ (see Definition \ref{def:morphism of tables}).  The limit of this diagram is the table $$\begin{tabular}{|l|l|l|}Title&FirstName&LastName\\\hline\hline Dr.&Karl&Marx\\\hline Mr.&Groucho&Marx\\\hline\end{tabular}$$ as desired.

\end{example}

In the example above, the table $\tau$ has two instances of the same string.  This is not superfluous because there are two people named Marx.  They are differentiated by their internal keys, but not by their attributes.  Keeping distinct objects distinct, even if they have the same attributes is very useful in practice.  It not only allows for lossless joins, but it is well-suited for database integration as well.

\subsection{Select}\label{subsec:select}

Selecting all entries of a given form, e.g. all entries in $\mcX_1$ whose `Last' value is ``Obama," is a special kind of join.  Namely, consider the ``selection" table with only one column, `Last', and only one row; fill its unique entry with the string ``Obama."  Let us denote this database by $\mcX_2$.  The initial database with one column, `Last', will be denoted $\mcX$; it obviously maps to $\mcX_2$ in a unique way, and it also maps in a unique way to $\mcX_1$.  The colimit of the diagram $\mcX_1\from\mcX\to\mcX_2$ in this case will return the records in $\mcX_1$ for which the `Last' value is ``Obama," as desired.

We can also select records that match multiple criteria by using a bigger schema for $\mcX$ and $\mcX_2$ above.  We can achieve disjunctive queries as well, by including more than one record in $\mcX_2$.  For example, we could ask for all people with name ``Obama" or ``Bush" using a table with two rows as our selection table. 

\subsection{Deletions}

Deletion can be subtle.  If one deletes entries in a subschema, the action must ``cascade" up the hierarchy, deleting entries in larger schema that refer or point to the deleted entries.  To that end, we define the following construction.  

\begin{definition}

Suppose given a schema $X$ and a subsheaf $\mcK_1\ss\mcK$ on $X$.  Let $\ol{\mcK_1}\ss\mcK$ denote the presheaf on $X$ with $$\ol{\mcK_1}(X'):=\{r\in\mcK(X')|\exists X''\ss X', X''\neq\emptyset, r_{X''}\in\mcK_1(X'')\}$$ for subschema $X'\in\Sub(X)$.  Here $r_{X''}$ denotes the image of $r$ under the restriction map $\mcK(X')\to\mcK(X'')$.  We call $\ol{\mcK_1}$ the closure of $\mcK_1$ in $\mcK$.

\end{definition}

Suppose now we want to delete all entries of a given type from a database.  More concretely, suppose $\mcX=(X,\mcK_X,\tau_X)$ is a database with schema $X$, that $i\taking S\ss X$ is a subschema, and that $\mcS=(S,\mcK_S,\tau_S)$ is a database of objects of this subtype, all of which we would like to delete from $X$.  As explained in Section \ref{subsec:select}, we can select the rows of $\mcX$ of the type specified by $\mcS$ by taking the colimit as in the diagram $$\xymatrix{(S,\mcU_S,\id_{\mcU_S})\ar[r]\ar[d]&\mcS\ar[d]\\\mcX\ar[r]&\mcX_\mcS\lrlimit.}$$  We know that $\mcX_\mcS$ has schema $X=X\amalg_SS$ and we momentarily write $\mcX_\mcS=(X,\mcK_{\mcS\ss\mcX},\tau_{\mcS\ss\mcX})$.  

The map $\mcX\to\mcX_\mcS$ includes a morphism of sheaves $\mcK_{\mcS\ss\mcX}\ss\mcK_X$ on $X$, and we take its closure $\ol{\mcK_{\mcS\ss\mcX}}\ss\mcK_X$.  By construction we can now delete this subsheaf objectwise on $\Sub(X)$.  That is, we define $$\mcK_{\mcX\backslash\mcS}(X')=\mcK_X(X')\backslash\mcK_{\mcS\ss\mcX}(X'),$$ where $A\backslash B$ denotes the maximal subset of $A$ which contains no elements in $B$.

The database $$\mcX':=(X,\mcK_{\mcX\backslash\mcS},\tau),$$ where $\tau$ is shorthand for $\tau|_{\mcK_{\mcX\backslash\mcS}}\taking\mcK_{\mcX\backslash\mcS}\to\mcU_X$, is the deletion of $\mcS$ from $\mcX$.  There is a canonical map $\mcX\to\mcX'$, and one can show that $\mcX'$ is the initial object over $\mcX$ whose join with $\mcS$ is empty.

\section{Applications, advantages, and further research}\label{sec:applications}

In this section, we discuss the applications of the category of simplicial databases.  First, simplicial databases can be used wherever relational databases are used; ours are more general but are closed under applying the usual queries.  However, there are many advantages to using simplicial databases rather than relational ones.  

In Section \ref{subsec:geometry}, we discuss how the geometry of a schema can provide an intuitive picture for the content of a database.  As an example of using category theory to reason about databases, we show in Section \ref{subsec:query} that query equivalences are trivially verified when one phrases them in categorical language.  In Section \ref{subsec:privileges} we discuss how diagrams of databases can give various users different privileges in terms of accessing and modifying data.  Finally, in Section \ref{subsec:further research}, we discuss further research on the subject and open questions.


\subsection{Geometric intuition}\label{subsec:geometric}

In Section \ref{subsec:schemas}, we defined the category $\Sch^\pi$ of schemas for a given type designation $\pi$.  They are based on geometric objects called symmetric simplicial sets.  In this section, we show that the geometry of these objects is intuitive and therefore useful in practice.

\begin{example}\label{ex:flights}

In this example, we consider a simplified situation in which one keeps track of the cities from which flights take off and those at which they land.  So suppose we have only one type, $\DT=\{`City'\}$ and $U$ is the set of cities in the world.  Let $X$ be the schema $$\xymatrix@1{~^\tn{`City 1'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^\tn{`City 2'}}$$  For our sheaf of keys $\mcK$, we take $\mcK(\tn{`City 1'})=\mcK(\tn{`City 2'})$ to be the set of cities in the world which have airports.  Over the 1-simplex $X$ take $\mcK(X)$ to be the set of pairs $(C_1,C_2)$ for which $C_1$ is the city of departure and $C_2$ is the city of arrival for some flight.  Let $\mcX$ denote this database of flights.

Now, joining this database with itself yields a database with schema \begin{eqnarray}\label{dia:layover}\xymatrix{\bullet\hspace{-.2cm}\ar@{-}[r]&\hspace{-.2cm}\bullet\hspace{-.2cm}\ar@{-}[r]&\hspace{-.3cm}\bullet}\end{eqnarray} whose global sections are ``flights with layover," i.e. pairs of flights with the destination city of the first flight equal to the departing city of the second flight.  Similarly, the database of multi-city trips of a given length $n$ is simply the union of $n$ copies of the database of flights $\mcX$ in this way.

Moreover, if we want to use $\mcX$ to find the set of available round-trips, we simply join the ends of the schema in Diagram \ref{dia:layover} to make a circle \vspace{.1in}$$\xymatrix{\bullet\ar@{-}@/^1pc/[r]\ar@{-}@/_1pc/[r]&\bullet}$$\vspace{0in}  This is not just schematic; we have literally taken the colimit of a diagram of databases.  The result is a new database whose global sections are precisely the pairs of flights which constitute a round-trip.

The point is that one can intuit this result by looking at the shape of the schema. 

\end{example}

\begin{example}\label{ex:sex}

In 2004, Bearman et al. \cite{BMS} present data which shows that at a certain high school called ``Jefferson High," there is a statistically small number of sexual couples that later switch partners.  That is, if $B_1$ and $G_1$ are sexual partners and $B_2$ and $G_2$ are sexual partners, then it rarely happens that later $B_1$ mates with $G_2$ and $B_2$ mates with $G_1$.  As they say ``...we find many cycles of length 4 in the simulated networks, but few in Jefferson..."

Suppose then that we take their raw data and put it on the schema $$\xymatrix@1{~^\tn{`Boyfriend'}\!\bullet\hspace{-.1cm}\ar@{-}@<-.2ex>[r]&\hspace{-.2cm}\bullet^\tn{`Girlfriend'}}$$ which we denote $X$.  Visually, we represent two boys and two girls who switch partners as follows: $$\xymatrix{Boys&Girls\\\bullet\hspace{-.1cm}\ar@{-}[r]\ar@{-}[dr]&\hspace{-.1cm}\bullet\\\bullet\hspace{-.1cm}\ar@{-}[ur]\ar@{-}[r]&\hspace{-.1cm}\bullet}$$ (where, say, horizontal lines represent the original partnerships and diagonal lines represent the new partnerships).  And indeed, we can take the colimit of four copies of $X$ along various vertices to obtain a database with the above 4-cycle schema.  Over every edge, the database will have Bearman et al.'s raw data.  The global table will automatically consist of all 4-cycles in that data.  

As in Example \ref{ex:flights}, the point is that the shape of the schema is intuitive.  Using schemas that are geometrically intuitive may enhance the ability of users to make sense of the data.


\end{example}

\subsection{Query equivalences}\label{subsec:query}

Joining tables together is very costly.  If one only wishes to consider certain rows or columns of a join, he should isolate those rows or columns {\em before} performing the join, not after.  For that reason, one is taught to ``push selects and projects," i.e. do those operations first.

How does one prove that it projecting first and then joining will result in the same database as will joining first and then projecting?  The proofs of results like these are generally tedious.  In this section, we do not claim any new results.  We merely show that these simple query equivalences are obvious when one uses the language of simplicial databases and knows basic category theory. 

For example, it is a standard category-theoretic fact that, in any category $\mcC$ with colimits, there is a natural isomorphism $$(A\amalg_BC)\amalg_DE\iso (C\amalg_DE)\amalg_BA.$$  Note that both joins and selects are examples of such colimits (see Sections \ref{subsec:join} and \ref{subsec:select}).  This formula applies to the category $\Data$ of databases and proves that ``selecting $E$ from a join of $A$ and $C$ gives the same result as first selecting $E$ from $C$ and then joining the result with $A$.

Projecting a database to a subschema is easy to describe in the theory of simplicial databases: one simply restricts the sheaf $\mcK$ and the map $\tau$ to that subschema (see Section \ref{subsec:projections}).  The fact that projects commute with joins reduces, using basic sheaf theory, to the simple fact that $(A\cup B)\cap C=(A\cap C)\cup (B\cap C)$.  

\subsection{Privileges}\label{subsec:privileges}

The sheaf-theoretic nature of our conception of databases lends itself nicely to the idea of privileges.  It often happens that one wishes to give certain users the ability to modify certain sections of the database but not others.  If $X$ is the schema for a database $\mcX$, perhaps we wish to give a certain user the ability to modify data on the subschema $i\taking X'\ss X$.  

To accomplish this, note that there is a map of databases $$\mcX'=(X',i^*\mcK_X,i^*\tau_X)\too(X,\mcK_X,\tau_X)$$  We allow the user to see $\mcX'$ as a database and make changes to it (we could also limit the ways in which this user can modify $\mcX'$: only allow insertions, for example).  At any given time, the user only sees the sub-database $\mcX'$.  

Suppose he adds a few lines to the sheaf $i^*\mcK_X$ to make it $i^*\mcK_X\cup\mcL$.  To update the main database, we simply take the colimit of the diagram of sheaves $$\xymatrix{i_!i^*\mcK_X\ar[r]\ar[d]&i_!(i^*\mcK_X\cup\mcL)\\\mcK_X}$$ and the result will be a new sheaf on $X$ with the appropriate insertions.  

Deletions are handled in a somewhat different way, but the idea is the same.  If the user deletes data from the sheaf $i^*\mcK_X$ to obtain the sheaf $i^*\mcK_X\backslash\ol{\mcD}$, then to update the main database may require us to delete entries from larger schemas.  Assuming that we have really given the user the capability to delete, the updated sheaf on $X$ will be the limit of the diagram $$\xymatrix{&\mcK_X\ar[d]\\i_+(i^*\mcK_X\backslash\ol{\mcD})\ar[r]&i_+i^*\mcK_X.}$$

Again, we are not claiming that privileges of this type are anything new.  We are claiming that they are naturally phrased in this categorical language, thus bringing a new and powerful mathematical tool to bear on the problems of the subject.

\subsection{Further research}\label{subsec:further research}

The category-theoretic and also geometric nature of simplicial databases opens up many directions for future research.  We present a few in this subsection that we intend to pursue.  Many of these ideas were suggested to us by Paea LePendu.

\subsubsection{Topological methods}

First, we would like to consider how we might use methods from algebraic topology to study databases.  We already saw in Example \ref{ex:sex} that topological ideas can have real world meaning.  Another example would be given by ``lifting problems."  Problems of this sort include the famous question ``are there three foods, each pair of which taste good together when eaten together, but the threesome of which tastes bad when eaten together?"  Managers of online social networks may be interested in collections of people in which every pair is friendly.  These types of phenomena can be represented geometrically, so having simplicial sets as schema may be useful for their study.

Homotopical methods from algebraic topology may also be useful.  When one object ``morphs" into another in time, it is difficult to know how to treat it in a database.  Homotopy theory is the study of gradual transformation through time, and we see some potential for using it to study real-world phenomena.

Finally, the geometric nature of our schema may be useful for query optimization.  Schemas can be measured in terms of their geometric structure.  It may be that in performing many queries, a database management system learns that some geometric structures are being used more often than others.  The patterns which emerge may be only visible when one uses schemas that have this geometric nature.

\subsubsection{Database integration}

We believe that having a rigorous definition for {\em morphisms of databases} (see Definition \ref{def:database morphisms}) will be of use in the problem of database integration.  The morphisms of databases can account for changes in schema and in data.  It is also easy to allow changes in data types as well, a topic we will address in later work.

Also, as mentioned in Remark \ref{rem:internal keys}, the use of internal keys should prove immensely valuable.  Instead of including an arbitrarily chosen identifier for an object as part of the data for that object, as required in the theory of relational databases, our theory keeps these identifiers separate.  When attempting to integrate databases, it is imperative that one know which sections of the data are observed and invariant properties of the objects being classified, and which sections of the data are arbitrarily assigned for management reasons.  Our theory keeps these sections of the data distinct, by use of a sheaf of keys $\mcK$ that is not considered part of the data.

In future research, we hope to show that database integration is substantially easier when one works with a rigorous and geometric model like the one we present here.  Before we do so, we need to explain how to work with a change in type designations, which is not hard, and how to deal with constraints in the data.  See Section \ref{subsubsec:types} for our plans in this direction.

\subsubsection{Ontologies and networks}

One intuitively knows that there is a connection between databases and ontologies.  An ontology is meant for organizing knowledge, a database is meant for organizing information, and there is a strong correlation between the two.  In order to make this correlation precise, one must first find precise definitions of ontologies and databases.  Further, these definitions should be phrased in the same language so that they can be compared.  Category theory was invented for the purposes of comparing mathematical structures, and as such provides a good setting for this project.

Our plan (see \cite{Spi2})) for a categorical definition of communication networks involves annotating the simplices of a simplicial set with databases.  That is, each node in a network has access to a database of ``what it knows," and connections between nodes allows communication via a common language and set of shared knowledge.  In order to make this precise, we need a precise definition for a category of databases, which we have now given.  

\subsubsection{More exotic types}\label{subsubsec:types}

Throughout this paper, we have fixed a type designation $\pi\taking U\to\DT$, where $\DT$ is a set of data types, and $U$ is the disjoint union of the corresponding domains.  This allows for types like Strings, characters, dates, integers, etc.  It also allows for more general types like ``functions from $A$ to $B$" or ``probability distributions on a space."  

However, as flexible as our type designations may be, the situation can be generalized considerably by allowing $\pi$ to be a functor between categories, rather than a function between sets.  The simplest application is one that is already implicitly used, namely sorting data.  The set of strings is in fact an ordered set, and so can be represented as a category (with a morphism from $A$ to $B$ if $B$ is lexicographically larger than $A$).  Another application comes from putting constraints in the data, like if we only allow (city,state) pairs for which the city is in the state. 

By generalizing type designations to include categories rather than sets, we open up many new possibilities for making sense of data.  Causal relationships can be represented, as can processes.  In short, morphisms make the theory more dynamic.  


\bibliographystyle{amsalpha}
\bibliography{biblio}


\end{document}